23. 07 . 25
UI 디자인 : 사용자가 편하게 아름답게
UX 디자인 : 사용자 만족했느냐 ( 정보가 유익했다/ 도움이 됐다)
굿디자인 : 재미있고 유익한 웹/앱 사이트를 제작

Edit : vsc 
환경설정
 lice sever : 결과미리 보기
auto rename : 앞뒤 태그를 같게 해줌
elm emmet :빠른 코딩 (자동코딩)
ctrl + : 크게
ctrl - : 작게

웹
<!DOCTYPE html>    // html5  문서임을 표시

tml                               tml 시작


<head>
<tittle>테스트문서</tittle> 문서제목
<meta charset=""utf-8" />  사용 코드 이름 : "utf-8 (유니코드) 전 세계 언어를 표현가능 코드
<head>  
                        이문서의 정보를 제공
</body>
  본문 내용 시작
 정보를 제공
tml           끝
shift + a/t + 밑 화살표: 같은 줄 복사

태그(명령어)
태그 안에 있는 옵션을 속성
img 태그 안에 src 속성은 경로를 의미한다.

<br> : 줄 바꿈 태그
<p> :  문장태그 자동으로 줄바꿈(2줄)
 - p태그안에 p 못들어간다
 - p태그안에 div 못들어간다
img : 그림태그
div : 항복구분 태그 (공간 구분 태그)
 -- div태그안에 div 들어간다
  -- div태그안에 p 들어간다

  span : 글자태그
  img : 그림태그
  inline요소 : 한줄에 여러개의 태그가 온다 (span, img,a)
  blick 요소 : 한 줄에 하나 개의 태그만 온다(p,div,li,ul)




 <img src="img 4.jfif" alt="">

html : 

인터넷에 데이터를 표시해 주는 언어
css: html을 디자인 해주는 언어
디자인 방법(style)

<p style="border: 1px solid black">
inline style : 태그 안에 스타일 지정
내부스타일 : <head>와 </head> 사이에 스타일 지정
margin: 바깥쪽
<table> :표 만들기
<tr> : 줄만들기
td : 칸 만들기
td*2 : 두줄 만들기
ctrl + /: 주석 (해설) - 실행하지 않음
 - 가운데로 옮기기
margin: : 테두리가 가운데로 이동하는 것
<text-align: center> : 글씨 가운데로 옮기기
<font-size: 20px;> : 글자 크기 조절
<height: 70px;> : td 높이 조절
<border: 1px solid black;> 표 줄 색깔

 <table cellspacing="0"> : 칸 붙이는 거
 <caption> 햄버거 비교표</caption>: 제목크키
 </thead> : 제목 소개
 </tbody> : 본문내용
 선택자 : 특정 태그를 지정할 수 있다.
 - class, id, name, tag, > ~
 - class : (점)으로 표시, 중복 사용이 가능하다. 
cursor: pointer; : 마우스 손가락으로 변신
background: 칸 색깔 바꾸기
color : wheat : 글자 색 보이기, 바꾸기
border: 1px solid 
파일 이름 바꾸기 f2
td colspan : 모양 맞추기
class="start" : 지정한 숫자 변하기
cellspacing : 표 칸 조절하기
class : 가능하다 중복이
hover : 마우스가 갔을 때 칸이 색깔이 변하는 것
인라인스타일> 내부스타일 >외부스타일
<td rowspan="2" : 밑에 줄이랑 합친

div.menu = <div class="menu">
inherit : 부모랑 똑같이 간다
div : 항복구분 태그 (공간 구분 태그)
line-height : 글자 높이 조정
display: flex; : (((가로로)) 만드는것
justify-content: space-between : 사이사이 공간을 만들어라
justify-content : center : 텍스트 가운데 공간을 없애고 가운대로 집합
글자 평균크기 : 16
rem : 글자크기 두배 
 글자사이즈:   font-size: 1.5rem; 1=16(크기 지정할수있다)
    background: url(../) 꺼내오는거
    width (가로)  height (세로)
    font-size: 3rem; : 글자크키
    border-radius: 표칸 꼭지점 각도?
    font-weight : : bold 글자 모양 변경

    list-style-type: none; 
    앞에 123 없애는 것
    padding : 0% 때만 앞에 안뛰게 하는 것


<ol>순서 있는 목록 태그가
ul : 순서 없는 목록 태그
</ol>
<ul>
</ul>

position : 위치를 지정하는 속성 고정할수 있는 태그(광고 사이드)
absolute : 절대 주소 기준은 부모 ,합치는것
fixed : 고정된 주소 기준은 왼쪽 / 위쪽 (0.0)
relative : 상대 주소 기준은 자기 자리
top, left, right, bottom 지정 할 수 있다
z-index (레이어 개념) 위/아래 설정(레벨) 가장 위에 올라고 겠다
absolute fixed 설정이 되면 (위치를 지정) 공중에 붕 뜬다
옵솔르트와 픽스드는 높이는 퍼센트로 할수있다
transform: translateX(-50%) width : 150px = 70 
선택자 : class, id
id : #dmfh 표시, 중복 불가능 ( 자바스크립트에서 사용 가능하다)
<div class="skip" onclick="vid.style.display='none'">
    
    
    margin: 0; 바깥 테두리 공간
    list-style: none : li,ol,ul 왼쪽 시작을 없애주는 것
    padding: 0; 안쪽 테두리 공간

    p:
    span : 
    a: 문서를 연결 태그
      - 자동으로 손가락이 나온다
      -밑줄이 그어짐
      -글자색이 파랑
      -인라인요소
     -display: block 인라인요소를 블록으로 바꿔준다
    text-decoration: none : 모든 글자 꾸민 효과를 없애는 것
    <a href="">내용</a>     예 <li><a href=""> Hansot</a></li>
     -<a href="https://www.hsd.co.kr/franchise/hansot_store"target="ch">
     -<iframe name="ch" frameborder="0"></iframe> 이름 즉 네임을 설정을 ch를 해야한다
    ifame : 작은 화면 
    선택자 : class, id, name
    사진이 div에 있으면 div에 hover 를 지정해야 한다
     overflow: hidden : 자식이 부모보다 더 넘지 말라 사진 동영상 등등
     transition: 0.5s :시간을 조절
     transform: scale(1.5); : 커져라 
     transform : 커져라 이동해라 등등 명령할 수 있는 
     font-weight: bold: 글자 굴기 
     <iframe name="ch" frameborder="0" </iframe> 화면속에 화면 띄우는것
     src="https://www.hsd.co.kr/"> 새로고침해도 안없어지게 하는것


     시멘틱태그 : 의미있는 태그들 
     <header> : 제목 태그
     <nav> : 메뉴태그 
     <section> 본문 내용 태그
     <article> 상세 내용 태그
     <footer> 꼬리말 태그(회사주소/전화번호 기타등등)
     <aside> 광고/배너
     
     display 를 쓰면 
     justify 와
     align-items: center: 세로 높이를 센터로 옮겨라 
     display: 

     웹폰트 : 인터넷 상에서 웹아이콘 제공(구글)
     자식 태그에 position을 설정하려면 부모 태그에도 position이 있어야 한다
     (없으면 자식 태그들은 부모를 벗어난다.)
    text-indent : 글자를 이동
      <small> : header제목보다 조금 작은 글씨할때

    position: relative(부모) : position: absolute 이걸 할려면 부모가 잡아줘야한다
     position: absolute(자식) : 하나로 모이게 하는것
     
     animation : 움직임
     -움직임의 시작 : from /0%
     -움직임의 끝 : to 100%
      animation-fill-mode: forwards : 움직임 했다가 마지막에는 멈추는것

     center: 글씨 가운데로
    fontawesome : 이모티콘 다운 받을 수 있는 곳
    overflow: hidden : 지정된 부모의 크기(높이,가로) 넘어가는 글씨는 다 숨기는 것
    relative:
    border-radius: 15px; : 테두리 모서리 조정


     <section>
         컴퓨터(대분류)
          <article>
              프로그램
               <section>
               자바 
                  <article>
                     연산자
                  </article>
               </section>
          </article>
      </section>

      text-indent : 글자를 이동
      <small> : header제목보다 조금 작은 글씨할때


2023.08.03

  javascipt

  alert(내용표시 api) : 내용 표시 명령어
  우주.은하계.태양계.지구.한국.서울.마포구.중앙정보처리학원=10;
  jQuery 사용 
  

 데이터/정보 

  데이터 종류 : 
  원시 데이터 (type) : 더 이상 분해 할 수 없다.
      1.Number : 숫자
      2.string : 문자
      3.Boolean: 명제(true/false)  
      4.undeflned : 값이 지정되닌 않은 상태
      5.Null : 값을 모르는 상태
  오브젝트 데이터형(type) : 원시 데이터의 모임
      1.배열(array)
      2.객체 (object)
      3.클래스

  변수 : 데이터값를 기억하는 임시 기억장소 (let abc-"홍길동";)
  변수 선언법
      1.var : any타입(어떤값이든 저장 가능)
      2.let: 같은 타입 데이터만 입력
      3.const: 값을 고정시킨다.(상수지정)
  변수 만드는 법
      1. 영문자로 시작,$,_(언더바) 시작해야 한다.
      2.변수 사이에 공백 사용불가( ab= c =10;)
      3.특수문자 사용 불가(a?b=10;)
      4.예약어 ( 명령어 ): (for=10;)
      5.변수 작명법 : 의미있는 단어(쇼핑몰 price =danga+su )
                      name= '홍길동",age= 20;
      카멜표기법 : 두 개의 단어로 변수/함수 명을 작성 할 때 두번째 첫 글자는 대문자로 쓴다
                    (cardpoint = 20;) 
     파스칼표기법 : 각 단어 첫 글자를 대문자
                    (Cardpoint = 20;)
      어더스토러 표기법 : 단어 사이에 언더바 넣기
                      (card _point = 20;)






  자바스크립트 기본 문법
  1. 한 문장이 끝나면 ;(세미콜론) 해야 한다.
  2. 대.소문자를 구분 (소문자 기본)
  3. 주석(설명문)
          한 줄 주석://
          여러 줄 주석:/*와 */사이에 있는 것은 실행하지 않음
  자바스크립트 실행 후 html 실행해라

  함수= function: 실행문 (모임) 처리문
   - 괄호가 있으면 함수로 인식 
   alert("알림"), write("출력 내용")


          document.write : 화면에 띄어라

          축약형 수식
          변수 = 변수 + 10;
          증(감)연산자
          count++; //후위 증가 연산자
          ++count   // 전위 증가 연산자



2023.08.04

반목문 : 예제 - 시각적 구현 ( 스타일 )

for(i=1; i<=5; i++) {

    1초기값   2비교값  4증가값


    document.write("<br>자동차-" + i)
    ---------------3실행문
}

연산자 : 산술연산, 논리연사, 관계연산,
산술연산: + ,-  ,/ ,%(나머지연산자)
        10%3...1 9%5...

        엔티티코드 : 기호 명령어 볼 수 있는 사이트
        getElementById: id로 지정해놓을때는 이걸 쓴다(자바스크립트)
getElementsByTagName : 부모안에 자식태그를 지정할때 (자바스크립트)
querySelector:
iumsu에는 .jumsu(class) 태그가 들어감
boolean : 데이터형 명제 ( true/false)
                        true 숫자가 있으면 참,541, -1,-5
                        false, 숫자 0 
if(변수) 
||:or 
&&:And 그리고

 var.let
 const : 정해진 값, 변경 할 수 없는 값
 const  abc=20 pi
 abc=20;
 배열: 같은 타입의 데이터를 순서대로 기억시키는 기억장소의 집합
 [첨자]를 사용한다.(index값을 지정-검색순서 )
 -문자역 배역:[대괄호]사용, 콤마로 데이터를 구분한다.
 const dataA=["국내"] 문자열 배열 선언 초기값

 프로그램 작성 도와주는 프로그램들
 API 
 애플리케이션 프로그래밍 인터페이스
 자바 - 클래스 패키지
 자바스크립트 - 라이브러리(jquery,React), 프레임워크
 jQuery : 

setinterval(함수명,시간) : 일정 시간마다 반복 실행 해 주는 함수
함수 = function = 실행문(가능)
    - 내장 함수 ,사용자정의함수

    2023 08.09
    css: animation: 애니메이션이름, 실행시간 linear infnite

    javascipt : animation( { "대상" : "값" },수행시간);
                animation({"left" :   "-1000px})
                animation({"left" :   "-=1000px})

weight(조건) { // 조건이 만족될 동안 실행
        break; //}
        
        
        
        function(함수-메소드(자바)) : 실행문을 저장한 코드 모임
        -함수 선언
        function 함수명() {
            실행문..
        } 
        function 기능(역할)
        -반복작업을 수행
        -데이터 전달 
        -재활용이 가능
        -프로그램을 삭제,수정,유지보수가 쉽다.

        let str = "abcdefg" //문자역 =배역
        let out = str.replace('c','x');
        console.log( out);
        -내장함수 / 사용자 정의 함수

        함수 호출 
        parijy.dothome.co.kr


    2023.08.16

        java 설치 
        java 호칭
        -JDK : 개발도구
            JRE : 실행 환경
                JVM : 자바가상머신(번역 - 바이트:원도우,리눅스,유닉스)
        -안정적인 버전 : 8,11,17-(21년도)
       
        https://adoptium.net/

        
        클래스 중심으로 처리됨
        정의 : 객체를 생성할 수 있는 형태
        기능 : 속성과 연산구조를 정의
                속성(멤버변수)  : 객체가 갖는 기본값 정의
                연산 (메소드 = 멤버함수)       

        구조 : 속성 : 초기값
               메소드 : 실행함수 
               인스턴스 : 객체의 실체
               접근자 :  PUBLIC,protected, default, private
        클래스
            데이터(배열) + 함수 : 관련되어 있는 데이터
            설계도
            사용자 정의 함수 정의

        java 플랫폼이 os 위에서 실행
            플랫폼 : 프로그램이 동작할 수 있는 실행 환경
            java플랫폼 : java(SE (스탠다드)/EE(엔터프라이즈/ME(모바일)))
            
            JAVA project : 전체작업
                        package : 작업 묶음
                            class : 객체를 만들 수 있는 형태(틀)
                                속성 : 상태값
                                메소드 : 실행(동작,기능)
        -------------------------------------------------------
        class: 객체를 생성 할 수 있는 형태(틀)

        클래스 3가지 구성요소
         -필드(속성) : 클래스에 포함된 변수
         -메소드(method) : 클래스 안에 있는 함수
         -생성자 (constructor) : 객체(인스턴스)가 만들어 질때 초기값 전달

        객체지향 : 객체를 중심으로 프로그램이 실행
        (반대말 <---> 절차형 프로그램 : 위에서 아래로 순서대로 프로그램이 실행)
        객체 : 속성과 메소드를 갖고 있다.
        사람 hong = new 사람();

        클래스 객체명 = new클래스();
        Scanner scanf = new Scanner(System.in)


    public  class     Print 
    -------  ----     -----
    공용    형태(틀)   클래스명
    ※ public  class가 붙어있는 클래스명이 바로 파일명이다.
       하나의 파일에 하나의 클래스가 있다.
       여러개의 클래스가 있을 수이 있다. (public은 하나의 모든 클래스에만 있어야 함)
    출력 명령어의 구성 : java.lang *; 기본 패키지 안 모든 클래스 
    System.  out.   println("ok");
    클래스    필드   메소드

    windo-pret-{auto java} - (EDIT 선택) -Content assist: 밑에서 2번째 a-z
    API 찾아보기 java api
    -----------------
    int : 정수 선언             int int_value = 10;

    string : 문자열 선언,"(쌍따음표)로 묶어주어야 함, 글자들
        String str ="홍길동";
		System.out.printf("\n문자열 값 출력 : %s",str);
		



    char ch = '홍';  // 문자는 한 글자, '(따음표)로 해야만 함
		System.out.printf("\n정수값 출력 : %c",ch);
		System.out.println("---------------------");


    Double dou = 65.748568;    //실수형,출력은 %f 기본 소수점 6자리까지 출력
		System.out.printf("\n실수 갑 출력 : %f",dou);
		System.out.println("---------------------");
		

    Boolean boo = true;    //Boolean 타입(형), 참과 거짓으로 표현, %b로 사용
		System.out.printf("\n참(true)/거짓(fales)값 출력 : %b",boo);

    -----------------
    ctrl + alt + 화살표 아래 : 줄 복사

    System.out.printf("출력양식")
    %d : 정수
    %f : 실수 
    %c : 문자
    %s : 문자열
    %b : 논리

        리터럴 : 표현값(value) -정수, 실수, 문자, 문자열,논리값
            -정수 리터럴 : 10진수, 8진수, 16진수, 2진수
            -실수 리터럴 : 소수점형태, 지수형태, double 타입
        상수 : 정해진 값 final 선언
                대문자 사용
                값이 변하진 않는 수
                다시는 값이 변경할 수 없는 수

        화폐 갯수 출력
        23456원
        만원 2장
        천원 3창
        백원 4장
        십원 5개
        일원 6개

        Scanner 클래스는 java.util 패키지 안에 있다.
        scanf  .next() : 공백 이전까진 입력된 문자열을 읽음
            .nextInt() : 공백 이전까지 입력된 정수 읽음
            .nextFloat():공백 이전까지 입력된 실수 읽음
            .nextLine(): 줄바꿈(엔터) 전까지 쓴 문자열 모두 읽는 메소드
        p496
        java.lang 패키지 내용 : 가장 기본적인 클래스 들이 들어있다.
      - Object : 자바 클래스의 최상위 클래스
                    System, string , Math,Class
        Object 클래스는 객체 만들고 메소드를 정의 했는데 주요 메소드
                string toString() : 객체 문자 정보를 리턴
                int hashCode() : 객체의 해시코드를 리턴
                boolean equals(Object obj) ; 객체의 번지를 비교해서 결과 리턴
        System 클래스 : JVM(자바가상머신)번역(인터프리터)OS 일부 기능 사용
                필드:out(출력-콘솔),    err(에러),  in(키보드 입력)
                메소드
                        exit(int status) : 프로그램 종류
                        currenTimeMills() 현재 시간을 밀리초 단위로 long 값으로 리턴
        string 클래스로 객체를 생성해서 사용(기본적으로 사용 가능)
                메소드
                        append() : 문자열 끝에 추가
                        insert() / delete()
                        toStning() : 문자열을 리턴
                        replace(시작위치, 끝 , 위치 ,문자열) 
        Math : 수학 함수
                    메소드 
                            Math.abs() : 절대값
                            Math.cell(): 무조건 올림값
                            Math.floor() : 무조건 내림값
                            Math.max() : 가장 큰 값
                            Math.min() : 가장 작은 값
                            Math.random(): 난수 발생 ( 0~1 사이의 숫자)
                            Math.round() : 5를 기준으로 반올림값
        메소드(멤버 함수):실행 가능한 프로그램 (기능,동작)
        1.클래스 내부, 외부,생성자 등에서 호출 해야만 실행
        2.클래스 내부에서 호출은 메소드명();으로 호출하다.
        3.클래스 외부에서 호출은 클래스가 만든 객체를 통해서 메소드가 호출(참조변수) 된다.
        4.내부 메소드는 클래스의 멤버함수로 존재한다.


    2023.08.17

        JAVA템플릿 구성(소스파일 구조)
        프로젝트
        패키지  
            클래스
                멤버함수(메소드) 
                멤버변수(속성=필드)
                main()


        클래스
       정의(역할=기능=동작):객체를 생성할 수 있다
        구성:
                멤버변수(속성=필드) : 객체의 기본값
                멤버함수(메소드) : 동작,기능,실행

        ※클래스명의 첫 글자는 대문자로 한다.(System.out.println)()
        변수,메소드명 : 첫 글자는 소문자로 시작
        상수: 변하지 않는 값(상수명은 전체를 대문자)
        public이 붙은 클래스명은 파일이름(.java) 자바 실행파일의 확장자 .class
        일반 클래스는 publid을 쓰지 않는다.

        객체 : 클래스가 생성한 Object로써 메소드를 갖고 있다.
        인스턴스 : 클래스에서 생성된 객체의 호칭(실제값)

        메소드(멤버함수) : 실행 가능한 프로그램을 코드를 갖고 동작을 한다.
                메소드 사용법 : 클래스 내부,(다른 클래스)외부,생성자에서 호출해야만 사용 가능
                               클래스 내부에서는 메소드명();으로 호출된다.
                               클래스 외부에서 호출은 클래스가 객체를 만들어서 객체를 통해서 호출(참조변수)
        
        pubilc : 접근 지정자 중의 하나로 공용으로 사용할 수 있음을 선언
                 public static void main() : static 메모리 영역에 고정(static)되어 누구나(public) 사용가능
                 프로그램은 main()에서 시작해서 main()으로 끝난다. (main 메소드는 Retum 값이 없다.(void))
        
        자바 Base 모듈 : java.lang.java.util.java.text ....
                (프로그램 단위)
        
        java.lang 패키지 안에 있는 클래스 6개 중 3개만 말해보세요 : Object,System,string,Math,Class,래퍼클래스(포장클래스)
         
        System 클래스에 들어있는 필드 3가지 :  System.out , System.in, System.err
        System 클래스 : java.lang 패키지에 들어있는 클래스
        System 클래스에 있는 입출력 메소드 3가지 : out.println, out.printf, out.print
                out.printf : 출력 형식(포멧)의 지시자
                        %d:정수      %f:실수    %c:문자      %s:문자열       %b:논리
                

        자료형 타입 소개 
                기본형
                참조형
        --------------------
                기본형  : int, char, Double, Boolean
                 -정수형 : Byte(1),int(4),short(2),long(8)
                 -실수형 : float(4),double(8)
                 -문자형 : char(2) - 유니코드 : 전 세계 언어들을 표현 가능한 코드
                 -논리형 : boolean(1)     // 참,거짓 (true,false)
        

        API : 애플리케이션 프로그래밍 인터페이스
              -----------           ----------
                응용 s/w              연걸(조작방법)

        자바 API 검색 구글 java api documentation
        -------------------------------------------------
        참조 타입 (reference type)
         -객체 형태로 저장됨
         -실제 값이 저장된 메모리 주소를 저장해서 사용하는 데이터 형태
         -String str= "abcd"; 문자열 참조 타입
         -int arr= (10,20) 배열도 참조 타입
         -기본 자료타입(primitive)을 객체로 취급하기 위해서 사용하는 클래스
         -기본 자료타입(primitive)은 값을 갖는 객체를 생성할 수 있는데 이런 객체를 "표장객체" 라고 함
         배열 안에 들어가는 값은 객체이고 그 안에 들어가는 값을 다루기 위해 참조 타입으로 변환한다.

         래퍼클래스 : 기본 자료타입으로 객체를 생성할 수 있게 만든 참조타입형(8개)
                     래펴클래스는 객체가 기본 데이터 유형을 저장 할 수 있는 특수한 클래스
         
         기본 타입 : 데이터일 뿐 -char       int    double boolean iong    short byte    
         참조 타입 : 객체 생성 가능 -Character Integer Folat Double  Boolean  Long  Byte  class, interface
         int abc = 123;   // 123이 문자이면 "123"

         BigDecimal 클래스 : 소수점을 다루는 연산에 참가(사용)
                            BigDecimal 클래스 java.math 패키지 안에 포함
                            BigDecimal 클래스를 초기화 할때 문자열을 인수 값으로 전달한다.
                            BigDecimal 클래스 문자열 이기에 산술연산이 안된다.
                            BigDecimal 클래스 메소드를 사용한다.
                            BigDecimal 클래스 값을 비교할 때는 compareTp7   

        
        Ascii Clde : 아스키코드
         -7비트로 구성된 코드
         -통신용으로 사용되는 코드
         -모든 문자에 해당되는 숫자가 있다.
         7(삐), 13(엔터), 32(스페이스), 숫자0(48) 숫자1(49)
         대문자 A(95),  대문자 A(90)
         대문자 a(97),  대문자 A(122)
         

    2023.08.18
         클래스 : 
                    정의 : 객체 생성 형태(틀)
                    구성 : 멤버변수,멤버함수
                    ※ 첫 글자 대문자,(필드와 메소드 첫 글자 소문자.)
         객체 : 속성과 메소드로 문제 처리
         인스턴스 : 클래스가 생성한 객체 즉 실제값
         메소드 : 실행 ( 동작, 기능) - 실행 가능한 프로그램을 작성해서 문제 처리됨
         public : 공동선언 
         API : 애플리케이션 (응용s/w/-사용자프로그램) 연결

         자료형 타입
                    기본형(primitive) : 값
                        정수형(byte,short,int,long)
                        실수 (float,double)
                        문자 (char)
                        논리 ( boolean)
                    참조형(reference) : 주소(메모리) 값을 기억하는 자료형
                    
                    참조타입 : 주소값,class , Array,String,Onterface
                        -기본형을 객체로 취급하기 위해 사용하는 클래스들
                        -왜 객체로 취급해야 하나요? 메소드를 사용 할 수 있다.(객체.legnth(),toString())
                        
                        -저장된 값은 주소를 저장
                        래퍼클래스: 기본 자료형으로 객체를 생성할 수 있게 만든 참조타입의 모임 
                                    Character,Inteher,Float,Double,Boolean,Long,short
                        자료형에서 
                        실제값 : value
                        주소값 : address
                        

        BigDecimal 클래스 : 소수점을 다루는 연산 ( 정확한 결과)
        -java.math패키지 안에 있다.
        -전달 인수 반드시 문자열
        -compareTo라는 메소드로 값을 비교

        리마크스
        1.선택 번호는 switch문을 사용

        저장영역
        데이터 영역 : 변수, 로컬변수
                    {} 끝나면 사라집

        static 영역 : 정적 영역
                    프로그램 끝날때 까지 기억
        힙영역 : 동적 영역,배열
                    필요에 따라 저장,


    2023.08.21
        
        Static영역(메소드영역): 프로그램 시작 ~ 끝 
                               클래스가 로딩
                                    클래스 변수,상수,생성자,메소드
        Stack 영역 : 스코프(중괄호= 블록) 내용(지역변수,매개변수,기본데이터형)
                    메소드가 종료되면 메모리에서 사라짐
                    스레드 객수마다 생성
        Heap(힙) 영역 : 동적할당(실행하면서) 사용되는 영역
                        참조형(배열, 스트링, 인스턴스)등이 저장되는 공간
                        (단 레퍼런스 변수는Stack에 저장됨)
                        메모리에 계속 남아 있다가 사용하지 않으면 Gc(가베지콜렉터)가 삭제한다.
        --------------------------------------------------------------------------------
        배열(Array) : 같은 타입의 데이터를 순서대로 저장하는 기억장소
        배열 선언: 참조형 변수 선언 
        배열 인덱스(첨자): 배열 안에 요소들이 갖는 순서번호
        인덱스 번호 0~4까지(0부터 시작함) 
          예)int[]  jumsu = new int[5];  //배열선언
             int [] jumsu = { 50,60,70,80,90 }      
                배열 지정하면 값을 넣는 것을 초기화
                배열의 크기는 변경 할 수 없다.()

        ==============================================================
        main 메소드에서 시작해서 main 메소드에서 끝난다.
        public static void main(String[] args) : 1개만 존재

        static 있다 : 클래스 멤버 (static 영역 - 정적) - 모든 객체에서 사용
        static 없다 : 인스턴스 멤버 (stack영역)        - 객체에서만 사용

        ※ 클래스 멤버는 인스턴스 메소드에서 사용 가능하다
        인스턴스 멤버는 객체를 생성한 후에 객체를 통해서 사용 가능하다

        static : 공동 정적 변수(static 영역 저장)
        1. 클래스 멤버가 된다.
        2. 모든 객체에서 공통적으로 사용 가능
        3. 모든 인스턴스에서 공통적으로 사용 하려면 static 붙인다.
        4. static이 붙은 멤버들은 객체를 생성하지 않아도 사용 가능
        5. static이 붙은 멤버들은 클래스(프로그램) 메모리로 읽어 들일 때  자동적으로 생성
        6. 클래스 영역에서는 멤버들만 쓸 수 있다.(일반 수식,값 변경 등은 멤버함수에서 한다.)

            내부 클래스 만드는 이유: 중요한 것이니까 
            좋은 점이 많으니까
            1. 객체 생성 없이도 (멤버변수/멤버함수) 사용 가능
            2. 상위 클래스의 속성/메소드 등을 상속 받는다.(쉽게 사용)
            3. 내부클래스는 상위 클래스 안에서만 사용되기 때문에 보안(캡슐화)이 가능하다
            4. 내부클래스 앞에 public,private,protected 모두 붙일 수 있다.
             (외부클래스는 pubilc만 올 수 있다.)
            5. 간단,복잡성,코드 길이도 줄어든다.
            6. 내부클래스는 static을 붙여준다.



             상위 (부모=외부 클래스)


            inter_tra
            멤버함수 run
            멤버변수 speed

    2023.08.22
        생성자 : 객체가 만들어 질 때 초기값을 위해 실행되는 (특별한)메소드
            객체가 생성될 때 자동으로 호출되는 메소드
            생성자 안에는 값을 초기화 하는 코드 있다.
            생성자 안에서 변수를 선언하지 않는다.

            생성자의 이름은 반드시 클래스 이름과 동일해야 한다.
            생성자는 메소드이므로 여러 개 작성(오버로딩)
            생성자는 new 연산자를 통해 객체를 만들 때 한 번만 호출된다.
            생상자는 리턴 타입이 없다.(값을 리턴하지 않는다.)

            매개 변수 (전달인수)와 실행코드가 없는 단순 생성자를 "기본 생성자"라 한다.
            디폴트 생성자라고도 한다.
            기본 생성자는 조건에 따라 자동으로 생성되기도 하고 직접 입력 해줘야 한다.
            자동생성 : 생성자가 하나도 없을 때 컴파일러가 자동으로 생성한다.
            생성자가 하나라도 있을 경우 기본 생성자는 자동으로 생성되지 않는다.


            this : 자신 (Class)

            Person 클래스에서 hong을 소개하는 생성자를 작성
                            lee 소개하는 생성자를 작성


    2023.08.22

        생성자 : 인스턴스 변수를 초기화(값)
        1.객체를 새로 만들 때 한 번만 실행
        2.왜 하는가?
            - main()메소드를 간단 명료하게 제작(편하다)
            -메모리 할당을 예약(참조변수)
            -네트워크 관련 작업 등 여러가지 기능
        3.생성자는 어떻게 만들어지는가?(규칙)
            -(메소드인데)클래스 이름과 같아야 한다.
            -new를 통해서 만든다.
            -리턴값이 없다.(void 안 쓴다.)
        4.모든 클래스는 생성자가 호출한다.(컴파일러가 자동으로 만든다.)
        5.기본 생성자 = 디폴트 생성자
            -매개변수가 없다.(전달값이 없다.)
            -클래스이름(); 자동으로 만들어준다.
            -사용자가 직접 만들어 놓을 수도 있다.
        6.생성자는 형태가 여러가지 이다.

        this : 참조변수,인스턴스,생성자에서 사용/ static(클래스)에서는 사용불가
        this() 생성자, this참조(주소)변수 (자기 자신을 가르친다.)

        생성자의 목적
        1.객체가 생성될 때 인스턴스 멤버변수를 초기화
        2.객체가 생성되는 순간 자동으로 호출된다.
        3.생성자 안에는 변수를 선언하지 않는다.
        4.생성자 이름은 클래스 이름과 동일하게 작성해야 한다.
        5.생성자는 메소드이므로 여러 개 작성(오버로딩) 할 수 있다.
        6.값을 리턴하지 않는다.


        기본 생성자
        1.매개변수가 없다.(하는 일이 없다.)
        2.자동 생성 또는 직접 만들기도 한다.
        3.생성자가 하나라도 존재하면 기본 생성자는 자동으로 만들지 않는다.


        상속 : 
        1.부모 클래스의 자원을 자식 클래스에서 사용 가능
        2.두 클래스 관계를 설정하는 것
        3.물려주는 쪽은 하나는 부모클래스 되고 받는 쪽은 자식 클래스가 된다.
        4.extend 키워드를 사용한다.
        5.부모 클래스 = 상위클래스=super클래스=기초클래스 : 멤버를 물려준다.
          자식 클래스 = 하위클래스=sub클래스 : 멤버를 물려 받는다.
        6. 자식클래스 ---> 부모클래스 (클래스 다이어그램)
        ※super(부모 클래스를 지칭한다.)
                자식클래스의 생성자의 매개변수가 있는 경우 super(매개변수) 생성자를 찾아간다.
                부모클래스의 생성자가 매개변수가 있는 경우에 사용한다.
                


        7.객체 생성시 찾아가는 생성자는 부모 생성자를 먼저 찾아간다.
            -자식 생성자에서 오버로딩 할때 부모 생성자가 오버로딩에 해당하는 생성자가 없으면 에러
            ( Hong(int age))-자식 생성자 매개변수는 1개
              부모생성자에서도 매개변수 1개짜리가 존재하면 문제없다.
                        (생성자가 아예 없으면 문제가 없다.-자동 생성이니까)
        가전제품: Element 클래스
                         weight=100
                         power=220
                         price=300

        컴퓨터 : Com 클래스 

    

    2023.08.24

        1.부모클래스의 모든 자원을 물려받는다.(private)
        2.두개의 클래스 간의 관계를 설정
        3.상속 받은 내용을 재정의 (오버라이딩) 할 수 있다.
        4.클래스-다이어그램 : 클래스와 클래스의 관계를 도형으로 그림
            (부모 클래스) <------(자식 클래스)
            클래스이름 - 멤버변수/멤버함수
        5.부모클래스 = 상위클래스 = super클래스 = Base(기초) 클래스 : 자원(멤버변수 / 멤버함수) 주는 쪽
            자식 클래스 = 하위클래스 = sub클래스 


        이론 = 개념실습 = 응용실습
        -------------    -------
        객체가 생성 될 때 생성자가 자동으로 호출된다.
        기본생성자(디폴트생성자) : 매개변수가 하나도 없는 생성자
        매개변수가 있는 생성자를 갖은 객체가 상속(extends)이 되면 반드시 super를 호출해야 한다.
        super를 호출해야 하는 이유 : 1. 안하면 에러가 난다. (자기방에 들어가려면 현관(부모클래스)을 열고 들어가야 한다.)
                                    2.super(부모클래스)에 자식 클래스에서 만든 생성자(매개변수 있는)와 같은 타입의 부모 클래스 생성자가 있어야 한다.


        오버라이딩 
         1.상속에서 생성된다.
         2.이름은 같고 내용만 다르다(재정의)
         3. 

         다형성 : 부모(자식)클래스의 결정에 따라 다양한(메소드 선택결정) 선택을 할 수 있다.
                  --------------------
                  부모 타입(클래스)속에 해당 메소드가 있느냐 없느냐에 따라 사용하느냐를 선택 할 수 있는 상태

         다형성의 대상 : (인스턴스 - 상속)의 메소드
         다형성 필요성 : 선택의 범위가 넓다.

         ※ 오버로딩 : 메소드의 매개 변수에 개수(형태,순서)에 따라 다르게 처리
            오버라이딩 : 상속 받은 메소드를 재정의(내용만 고친다) 하는 것(메소드 이름, 메소드 매개변수 바꾸면 안됨)
             

    2023.08.25
         객체(Object)지향프로그램(Oriented) 프로그램(Pregraming) : OOP
         OOP 사용 목적 (이유) : 확장성, 재활용, 관리가 쉽다   

         클래스 : 객체를 생성
         객체 : Object (클래스가 만들어 낸 Object다.)
         인스톤스 : 속성과 메소드를 갖고 있는 실제값
         속성 : (상태)값
         메소드 : 실행,동작,기능
         static : 공유 할 수 있는 고정된 값.(static가 붙은 클래스 멤버)


         생성자 : 객체가 생성 될 때 호출되는 (특별한) 메소드
         생성자의 목적 : 객체가 생성 될 때 초기화(값을 전달)
         1. new 키워드를 사용한다.
         2. 리턴값이 없다.(void 쓰면 안된다.)
         3.생성과 초기화를 동시에 한다.


         public : 공용(공개)
         private :  비공개
         protected ; 상속 범위 공개 
         default ; 같은 패키지 내 공개

         상속 : 부모클래스의 멤버를 자식클래스가 사용 가능 (extends)

         다형성 :  상위클래스가 하위클래스를 선택한다. (부모 클래스의) 메소드 선택 가능
                  부모클래스 = 자식클래스
                  
            sebaek@gmail.com

            System.identityHashCode(c); : 주소값을 보여주는 시스템

            hashCode() : 문자열이나 정수 등등 그 값에 숫자로 나타내여서 비교할때 숫자로 비교하니 편하게 비교할 수 있다.



             toString : 메서드는 객체가 가지고 있는 정보나 값들을 문자열로 만들어 리턴하는 메소드 입니다.
            getter 그 값을 반환하는 메소드
            settters 변수 값을 지정해주는 메소드
           

           private field : 속성 

           pubilc method : 기능
           
           private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;

    }

            메소드
           hashCode : 해시코드를 간단하게 말하면 해시 알고리즘에 의해 생성된 정수 값 
           hashcode()는 객체의 hashCode를 리턴한다.hashcode는 일반적으로 각 객체의 주소값을 변환하여
           생성한 고유한 정수값이다.
            equals : 오브젝트와 다른 오브젝트랑 같은지 다른 지 알려준다 같이 같은면 ture라고 나온다


            new A();     = Ctrl + A/t + v 하면 = 데이터 타입 변수 생성
            Ctrl + A/t + t  = surround 생성
            Ctrl + d : 줄에 있던 코드들이 밑으로 복사가 됩
             shift + A/t + 화살표 : 클릭했던 줄이 이동함





        09.06

        replace : 함수는 자신이 바꾸고 싶은 문자로 문자열을 치환시켜주는 기능을 한다
            String a = "화려강산 대한사람"
            a = a.reference("대한", "민국");
            System.out.printnl(a);
            //결과값 : 화려강산 민국사람

        replaceAll : 문자열 중에서 지정된 문자열 (regex)과 일치하는 것을 새로운 문자열(replacement)
                     로 모두 변경한다.

        wrapper class :기본 자료타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을
                        래퍼 클래스(wrapper class)라고 한다
                        기본타입을 감싸고 있는 클래스

    
    // 기본타입(primitive type) : byte,short,int , long, float, bouble,char,boolea
    // 래퍼 클래스 (wrapper class) : Byte, Shot, Integer,Long,Float,Double,Character,Boolean

    // boxing(박싱) : 기본타입-> 참조타입
    // unboxing(언박싱) : 참조타입 -> 기본타입


        //Arrays : 배열을 다루는 메소드들 있음
        //equals : 두 배열이 같은지
        //fill : 배열을 특정 값으로 채우기
        //sort : 배열 정렬
        //binarysearch : 특정 원소의 위치 찾기
        //toString : 문자열로 변환

        컬렉션 : 객체를 담고 있는 객체

        % : 나머지
        
        2의 배수 하고 싶으면
        
        class Solution 
    public int solution(int n) {
        int answer = 0;
        for(int i =0; i<=n; i++) {
           if(i%2==0) {
              answer+=i;
           }
        }
        return answer;
    }




        지네릭스 : 컴파일시 타입을 체크해 주는 기능
        ArrayList : 단순 배열은 객체 생성시 사이즈를 지정하지만,  ArrayList는 사이즈의 제한이 ㅓㅇㅇㅄㅎ다
                    배열과 같이 순서를 가진다
                    데이터를 추가할 때 add()와 addAll()이 있다.
                    List를 만들 때 내부적으로 배열을 사용하는것
        add() : 연결리스트에서 맨 뒤에 새 노드를 연결시키는 것과 같다. -> 뒤쪽으로 데이터가 쌓이고, 순서를 가진다
        addAll() : ArrayList에 다른 ArrayList의 데이터를 통째로 붙이기 위한 메서드이다.
                   인자로 Collection 객체를 받고 그 Collection 에 있는 아이템들을 리스트에 모두 추가한다.

        int와 Integer 차이점
        int : 변수의 타입(data type) 이다.
        자료형 : 산술 연산 가능함
                 null로 초기화 불가

        Integer : 래퍼 클래스 : unboxing 하지 않을 시 산술 연산 불가능함
                                null값 처리 가능 
                기본형을 객체로 다루기 위해 사용하는 클래스들을 래퍼 클래스 라고 한다
                그리고 Integer는 int의 래퍼클레스 라고 할 수 있다.

                형변환 : 변수의 타입을 다른 타입으로 변환하는 것이다
                        double d = 85.4;
                        int score = d; X안된다
                        int score = (int) d; // 강제 형변환

        Iterator : 컬렉션에서 요소를 제어하는 기능
                    next() 및 previous()를 써서 앞뒤로 이동하는 기능
                    hasNext()를 써서 더 많은 요소가 있는지 확인하는 기능

        배열의 인덱스 각 요소에 자동으로 붙는 번호

        
        LIFO  : 라스트 인 퍼스트 아웃 
            push : 
            pop : 마지막 메소드를 호출 ( 없어지는 것)
            peek : 마지막 아이템을 살펴보는 것 (없어지지 않는 것) 

            항등원 : 어떤 연산을 했을 때 자기 자신이 나오게 하는 것
            역원 : 어떤 연산을 (+,-등등)을 했을 때 항등원이 나오게 하는 것
           


           
        2023.09.13

    
             filter : 중개연산을 수행하는 메서드
                      주어진 조건자와 일치하는 스트림의 요소로 구성된 스트림으로 반환

            Collection 의 합을 구하는 방법은 reduce 와 sum 두 가지가 존재합니다.
                단, Stream 에서 sum() 을 사용하려면 
                IntStream, LongStream, DoubleStream 와 같은 기본형 (Primitive Type) 특화 스트림을 사용해야 합니다.
                그래서 보통 mapToInt, mapToLong, mapToDouble 같은 
                메소드로 스트림을 변환시키고 사용합니다.

                reduce : reduce(초기값, 연산) 형식으로 사용합니다.
                        초기값부터 시작하여 각 원소를 차례대로 순회하며 연산을 수행합니다.
                        이전 연산의 결과를 다음 초기값으로 넘기면서 연산의 결과를 누적해서 총 결과값을 구하는 메서드입니다.
                        int sum = Stream.of(1, 2, 3).reduce(0, Integer::sum);

                      sum() : Stream 의 총합을 구하는 메서드입니다.
                              기본형 특화 스트림에서만 사용 가능합니다.
                              int sum = Stream.of(1, 2, 3).mapToInt(e -> e).sum(); 
                                이 스트림에 있는 요소의 합계를 반환합니다. 
                                이는 축소의 특별한 경우이며 다음과 동일합니다.

                abstract : 추상 메소드(abstract method)란 
                            
                            
                            
                            
                            
                             수 있는 메소드를 의미합니다.

                collect : collect()는 Stream의 데이터를 변형 등의 처리를 하고 원하는 자료형으로 변환해 줍니다.

                stream : 컬렉션(Collection)을 기반으로 하는 스트림을 생성하는 메소드입니다.
                         데이터를 처리하고 변환하는 강력한 방법을 제공한다

                toList() : 스트림에서 필터링,매핑 또는 다양한 연산을 수행한 후 그 결과를 리스트로 저장하고자 할때
                           유용하게 사용됩니다.

                forEach() : 스트림의 각 요소를 반복하면서 해당 요소를 출력하는 방법 중 하나이다.
                            예 : List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
                                 numbers.stream().forEach(System.out::println);
                                 
                                 1
                                 2
                                 3
                                 4

        2023.09.14

        exception : 프로그램 실행 중 발생할 수 있는 정산적인 범위를 벗어난 경우에 처리를 하기 위한 방법

        try : try 안에서 오류가 뜨면 catch넘어가서 실행을 시킨다
        반대로 try 안에서 true면 실행이되고 catch 는 넘어간다 (실행이 안된다)
        
        e.printStackTrace() : exception 이 발생한 이유와 위치는 어디에서 발생했는지
                              전체적인 단계를 다 출력합니다 위치와 정확하게 알려주어서 어디서 에러가 
                              발생하였는지 빠르게 파악이 가능하다

        finally :
            //finally block;
            //exception 발생과
            // 관계없이 실행되는 block
            System.out.println("꼭 실행 코드");
            retrn 문을 만나도 실행이 된다


        ArrayIndexOutOfBoundsException : 잘못된 인덱스를 사용하여 배열에 액세스했음을 나타내기 위해 발생합니다. 
                                         인덱스는 음수이거나 배열 크기보다 크거나 같습니다.
                                         즉 : 잘못된 인덱스일때 실행 되는 것


        NumberFormatException : 애플리케이션이 문자열을 숫자 유형 중 하나로 변환하려고 
                                시도했지만 문자열에 적절한 형식이 없음을 나타내기 위해 발생합니다.
                                즉 : 문자열이 숫자 유형으로 변환하려고 할때 오류이면 실행되는 것


        Integer.parseInt : 인트로 분석해라 -> int value = Integer.parseInt(array[i]);
                                            (문자열을 숫자유형으로 바꿔라)

        에러 = 사용자가 어찌할 수 없는 문제
        예를들어 java명령어 자체에 오류가 있는 경우

        예외 = 사용자가 코드를 작성하면서 생긴 문제
        unchecked 랑 checked가 있는데
        un은 굳이 체크할 필요가 없음.
        체크를 안해도 실행됨.
        실행중에 예외가 발생하면 런타임예외
        RuntimeException은 unchecked exception 굳이 체크안해도 실행되는 예외

        checked exception은 반드시 체크를 해야됨
        체크하는 2가지 방법
        직접 try catch문을 사용하여 잡는법
        throws를 통해 상속받을 class안에서 try문을 사용하게 하는법

        throw : 예외를 강제로 발생시키는것이 바로 throw 입니다. 코드를 작성하는 프로그래머가 강제로
                예외를 발생시키는 것입니다.


          자바에서는 데이터를 외부에서 읽고 다시 외부로 출력하는 작업(입출력)에 스트림(Stream)을 사용함
          스트림은 단일 방향으로 연속적으로 흘러가는 것을 말하며, 데이터는 출발지에서 나와 도착지로 들어간다는 개념
          스트리밍의 특성이 단방향이므로 하나의 스트림으로 입력과 출력을 모두 할 수 없음
          프로그램이 네트워크상의 다른 프로그램과 데이터 교환을 하기 위해서는 양쪽 모두 입력 스트림과 출력 스트림이 따로 필요
          입출력 작업의 예: 키보드, 파일, 네트워크에서 입력과 모니터, 파일, 네트워크의 출력 
          프로그램이 출발지냐 또는 도착지냐에 따라서 스트림의 종류가 결정
          프로그램이 데이터를 입력받을 때는 입력 스트림(InputStream)
          프로그램이 데이터를 보낼 때는 출력 스트림(OutputStream)

    2023.9.18

     // %s : 문자열 출력
        System.out.printf("문자열:%s%n", "java");
    // %d :  정수 십진법 출력
        System.out.printf("정수 : %d%n",99);
     //argument_index$
        System.out.printf("정수2:%2$d%n정수1:%1$d%n", 100, 200);
        System.out.printf("정수:%1$d%n", 9, 8);
        System.out.printf("정수:%2$d%n", 9, 8);

        FileReader : 파일을 불러올 수 있는
        BufferedReader : 파일도 불러올 수 있지만 속도를 빨리 할 수 있는 기능이 있다

        join() : 메소드는 실행중인 쓰레드를 강제로 실행 대기(lock) 
                 상태로 변하게 한 뒤 특정 쓰레드가 실행되고 종료 될 때까지 기다리게 할 수 있다.

    

    어노테이션 : 코드에서 @으로 작성되는 요소를 어노테이션이라고 한다.(주석)


    enum
reflection
annotation

https://example.com /over/there ?name=ferret
         서버주소       경로      쿼리스트링(파라미터) request parameter

커리스트링:   이름 = 값 =으로 구분되어 있다.
             이름 값 쌍은 & 으로 구분되어 있다.
        
        
        모르는 단어들 :
             request.getParameter
             request : 리퀘스트 : 요청
             WebRequest
             require : 리콰이어드 : 요청된 : 
             



    @RequestMapping("sub2")
    public void method2(WebRequest request) {
        String name = request.getParameter("name");
        String address = request.getParameter("address");

        System.out.println("name = " + name);
        System.out.println("address = " + address);
        }
        위에 있는 코드를 밑에 있는 코드로 바꿀수 있다
        간편해 졌다.

    @RequestMapping("sub8")
    public void method8(@RequestParam("address") String adderess,
                        @RequestParam("married") Boolean married,
                        @RequestParam("age") Integer age) {
        System.out.println("adderess = " + adderess);
        System.out.println("married = " + married);
        System.out.println("age = " + age);
        }

            @RequestMapping("sub1")
    public void method1(@RequestParam String name) {
        System.out.println("name = " + name);
        }
        @RequestMapping("sub3")
    public void method3(String name, Boolean married) {
        System.out.println("name = " + name);
        System.out.println("married = " + married);
        }


        value = "age", required = false 로 구분할 수 있다 맞으면 age를 출력하고 틀리면 false로 출력
        value = "age",defaultValue = "10" Integer age

             required : 파라미터가 호출이 됐는지 안된는지
             defaultValue : 파라미터가 생성이 됐는데 작성이 안됐을때

        프로그램을 실행 될려면  쿼리파라미터와 메소드명과 매치가 되어야 한다




        @NoArgsConstructor : 파라미터가 없는 (기본생성자)를 생성한다.

        
        @RequiredArgsConstructor : final 필드를 파라미터로 받는 생성자 생성
        @AllArgsConstructor : 모든 필드를 파라미터로 받는 생성자 생성
        @DATA : get,set ToSTring 다 만들어주는 생성자



        @Controller
        @RequestMapping("main8")
        public class Controller08 

        @RequestMapping("sub1")
    public void method1(Model model) {
        model.addAttribute("attr1", "soccer1");}
        <h1>${attr1}</h1>

        프로그램 실행 시킬때 addAttribute(String object)의 String 을 view에서 <h1>${attr1}</h1>
        불러오면 된다.
        view프로젝트랑 파일을 만들때 main8프로젝트로 해야하고 sub1파일로 <h1>${attr1}</h1> 작성해야한다.





       


     String[] myname = {"내이름은","한","의","혁"};
        String[] you = {"1082cubi", "한메일"};
        String[] her = {"일산"};
        model.addAttribute("myName",myname);
        model.addAttribute("yourEmail",you);
        model.addAttribute("herAddress", her);
        
        순서를 먼저 배열을 지정을 하고 호출을 해야한다
        
     model.addAttribute("myName",new String[]{"lee", "kim"});
     이렇게 줄일수가 있다 객체를 생성해서

      model.addAttribute("list1", List.of("호날두", "메시"));
      또는 List를 이용해서 배열을 할수 있다 
      new String[] {}
      List ()
      
      var :
      var map3 = Map.of("1st", "hamburger", "2nd", "pizza");
      Map이라는 타입이 확실이 있으니까 var를 쓸수가 있다
       String[] you = {"1082cubi", "한메일"};
       var you = {"1082cubi", "한메일"};    //이건 오류가 난다 var 가 확실한 데이터 타입을 모르기 때문이다
        var her = new String[]{"일산"};     // new String을 붙임으로써 String 타입인걸 알았으니까 var를 쓸수가 있다

        jsp standard tag library
        (jstl)



EL 표기법
${ }

expression : 표현
language : 언어        
      
        begin과 end 포함해서 반복 end 는 begin보다 커야함 begin은 0보다 크거나 같아야함

        <c:forEach begin="0" end="2" var="num">
        <li>num : ${num}</li>
        </c:forEach>        : 숫자를 반복할려고 하고 var는 숫자를 반복할수있는 변수를 정했고
                              결과는: num: 0
                                     num: 1
                                     num: 2
        

  <c:forEach items="${names}
        items 는 namas를 가져오는 문법이다
        <c:forEach items="${myList}" var="i">
        <li>cars: ${i}</li>
        </c:forEach>    :  itmes는 가져오는 문법이다 그러므로 myList정보를 가져왔고 var="i"변수를 지정한것이다



    <a a1=""> : 태그라고 부르고 그 안에서 사용되는 애들은 attribute임.
        ex) a태그의 a1 attribute
        ex) <pig eat="" run=""> pig태그, eat이랑run은 attribute

    varStatus : var의 상태들을 알려주는 attribute

    varStatus가 가지고 있는 메소드는
    count, index, current, first, last등등 이 있음

    count : var가 몇번 시행 됐는지 알려주는 메소드
    index : 시행된 var가 몇번 index인지 알려주는 메소드
    current : 현재 var에 저장된 값을 알려주는 메소드
    first : 현재 var가 첫번째인지 논리값을 알려주는 메소드
    last : 현재 var가 마지막인지 논리값을 알려주는 메소드
    
    <c:forEach begin="4" end="7" var="i" varStatus="status"></c:forEach>
    
    1번 시행하면 i는 0
      status.count = 1
      status.index = 0
      status.current = 4
      status.first = true
      status.last = false
    2번 시행하면 i는 1
      status.count = 2
      status.index = 1
      status.current = 5
      status.first = false
      status.last = false
    3번 시행하면 i는 2
      status.count = 3
      status.index = 2
      status.current = 6
      status.first = false
      status.last = false
    4번 시행하면 i는 3
      status.count = 4
      status.index = 3
      status.current = 7
      status.first = false
      status.last = true







     단축키 : shift + shift(빠르게 연속두번) : 파일 찾는것
             원도우 + .  : 이모티콘
             intellij java 단축키
             ctrl + alt + v : 변수 생성
             ctrl + alt + t : surround 생성
             ctrl + alt + n : 중복 되는 변수 하나로 묶기
             ctrl + shift + t : test 생성
             ctrl + alt + shift + t : 리펙토리 메뉴
             ctrl + b : 현재 커서에 있는 맴버가 생성된 파일로 이동
             ctrl + alt + 좌,우 방향키 : 이전에 보고있던 파일로 이동
             ctrl + shift + f10 : 현재 class의 main메소드 실행
             ctrl + f10 : 가장 최근에 실행한 main메소드 실행
             shift + f6 : 맴버의 이름 변경
             ctrl + shift + f12 : 모든 윈도우 창 닫기

        <h4>+,-,*,/,%</h4>
<hr>
<p> a: 3 b :5 c : 8 d : 9</p>
<p>${a} + ${b} = ${a+b}</p>
<p>${c} + ${d} = ${c+d}</p>

<h5>-</h5>
<p>${a} - ${b} = ${a - b}</p>
<p>${c} - ${d} = ${c - d}</p>
<h5>* :곱하기</h5>
<p>${a} - ${b} = ${a * b}</p>
<h5>/ : 나누기</h5>
<p>${a} - ${b} = ${a / b}</p>
<p>${c} - ${d} = ${c / d}</p>
<p>${a} - ${b} = ${a div b}</p>
<p>${c} - ${d} = ${c div d}</p>

<h5>% : 나머지 연산(modulo,reaminder)</h5>
<p>${b} % ${a} = ${b%a}/p>
<p>${c} % ${a} = ${c%a}/p>
<p>${d} % ${a} = ${d%a}/p>
<p>${b} % ${a} = ${b mod a}/p>
<p>${c} % ${a} = ${c mod a}/p>
<p>${d} % ${a} = ${d mod a}/p>

<h5>()< : 우선순위 높음</h5>
<p>${a * b - c}</p>
<p>${a * (b - c)}</p>
<p>${(a * b) - c}</p>
구구단 2부터 9까지
<c:forEach begin="2" end="9" var="i">
        <c:forEach begin="1" end="9" var="j">
        <p>${i} X ${j} = ${j*i}</p>
        </c:forEach>
    </p>
</c:forEach>
구구단 9부터 2까지
<c:forEach begin="0" end="7" var="i">
    <c:forEach begin="1" end="9" var="j">
        <p>${9-i} X ${j} = ${(9-i)*j}</p>

    </c:forEach>
    </p>
</c:forEach>
<h4>||</h4>
파이프

if와 not 으로 할 수 있다 자바에서는 if 와 else로 구분되었다.
<c:if test="${param.name eq 'son'}" var="isSon">
    <p>hello son</p>
</c:if>
<c:if test="${isSon}">
    <p>여전히 son</p>
</c:if>
<c:if test="${not isSon}">
    <p>son이 아님</p>

<c:if> 태그에 사용될 수 있는 속성은 다음 세 가지 입니다.
    - test : 필수 속성으로 속성값으로 EL 비교식을 가집니다.
    - var : 조건 결과를 저장할 변수를 지정합니다.
    - scope : 조건 결과를 저장할 변수의 저장 scope을 지정합니다.
    <c:if test="${name eq '홍길동'}" var="nameHong" scope="session">
    </c:if>

<c:choose> 태그는 조건에 따른 여러곳으로 분기 가능하고, 
    조건이 맞은 것이 없을 경우 기본 분기를 제공할 수 있습니다.

    <c:choose>
    <c:when test="${name eq '김철수'}"> ... </c:when>
    <c:when test="${name eq '박영희'}"> ... </c:when>
    <c:otherwise> ... </c:otherwise>
    </c:choose>
    위 코드는 이름이 "김철수", "박영희" 일 경우 분기 하고 그 외의 경우에는 
    <c:otherwise> 로 분기 합니다.


   foo://example.com:8042/over/there?name=ferret#nose
     \_/   \______________/\_________/ \_________/ \__/
      |           |            |            |        |
   scheme     authority       path        query   fragment




1번 : 먼저 Controller12에와서 실행 시킨다 sub3이기때문에 그와 연결된 jsp에간다. 
    Controller12          
    @RequestMapping("main12")
    @RequestMapping("sub3")
    public void mathod3() {
    }

2번 : sub3 jsp에 오면 form안에 있는 것들을 먼저 실행한다.첫번째 위치한 text에는 name라는 곳에 저장되고 두번째test는 age곳에 저장이 된다
     그리고 전송버튼을 눌렀을때 그제서야 form이 실행이 되서 main12/sub4에 이동하게 된다
    @RequestMapping("sub3")
    public void method3() {
    }
    <form action="/main12/sub4">
        <input type="text" name="name">
        <br>
        <input type="text" name="age">
        <br>
        <button type="submit">전송</button>
    </form>


    
3번 : 다시 sub4와 연결된 Controller12로 돌아와서 실행을 시킨다. sub3에서 값을 받아온 name과 age는  @RequestParam("name") @RequestParam("age") 으로 받고 
        String name,Integer age 지정해서 System.out.println(name + "과 " + age + "를 저장함");  model.addAttribute("message", name + "과 " + age + "를 저장함");
        에 들어가는 name과 age로 들어간다
    Contrlooer12
    @RequestMapping("sub4")
    public void method4(
            @RequestParam("name") String name,
            @RequestParam("age") Integer age,
            Model model) {

        System.out.println("Controller12.method4");
        System.out.println(name + "과 " + age + "를 저장함");

        model.addAttribute("message", name + "과 " + age + "를 저장함");
    }

4번 : "${not empty message}" -> message안에 값이 들어있을때 실행을 하는 것. 순서대로 p태그를 실행을하고 <a href="/main12/sub3">새 이름과 나이 등록하러 가기</a> 것은
        a태그는 누르면 이동하는 것이므로 다시 main12/sub3으로 간다 즉 1번째로 다시 돌아가는 것이다
    body>
        <c:if test="${not empty message}">
            <p>${message}</p>
        </c:if>
        <a href="/main12/sub3">새 이름과 나이 등록하러 가기</a>
    </body>
   


    

      <c:if test="${not empty message}">
        <p>${message}</p>
    </c:if>

    <a href="/main12/sub3">새 이름과 나이 등록하러 가기</a>




모르는 단어 : 
modulo,remainder
    











     