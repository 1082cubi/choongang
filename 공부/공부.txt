23. 07 . 25
UI 디자인 : 사용자가 편하게 아름답게
UX 디자인 : 사용자 만족했느냐 ( 정보가 유익했다/ 도움이 됐다)
굿디자인 : 재미있고 유익한 웹/앱 사이트를 제작

Edit : vsc 
환경설정
 lice sever : 결과미리 보기
auto rename : 앞뒤 태그를 같게 해줌
elm emmet :빠른 코딩 (자동코딩)
ctrl + : 크게
ctrl - : 작게

웹
<!DOCTYPE html>    // html5  문서임을 표시

tml                               tml 시작


<head>
<tittle>테스트문서</tittle> 문서제목
<meta charset=""utf-8" />  사용 코드 이름 : "utf-8 (유니코드) 전 세계 언어를 표현가능 코드
<head>  
                        이문서의 정보를 제공
</body>
  본문 내용 시작
 정보를 제공
tml           끝
shift + a/t + 밑 화살표: 같은 줄 복사

태그(명령어)
태그 안에 있는 옵션을 속성
img 태그 안에 src 속성은 경로를 의미한다.

<br> : 줄 바꿈 태그
<p> :  문장태그 자동으로 줄바꿈(2줄)
 - p태그안에 p 못들어간다
 - p태그안에 div 못들어간다
img : 그림태그
div : 항복구분 태그 (공간 구분 태그)
 -- div태그안에 div 들어간다
  -- div태그안에 p 들어간다

  span : 글자태그
  img : 그림태그
  inline요소 : 한줄에 여러개의 태그가 온다 (span, img,a)
  blick 요소 : 한 줄에 하나 개의 태그만 온다(p,div,li,ul)




 <img src="img 4.jfif" alt="">

html : 

인터넷에 데이터를 표시해 주는 언어
css: html을 디자인 해주는 언어
디자인 방법(style)

<p style="border: 1px solid black">
inline style : 태그 안에 스타일 지정
내부스타일 : <head>와 </head> 사이에 스타일 지정
margin: 바깥쪽
<table> :표 만들기
<tr> : 줄만들기
td : 칸 만들기
td*2 : 두줄 만들기
ctrl + /: 주석 (해설) - 실행하지 않음
 - 가운데로 옮기기
margin: : 테두리가 가운데로 이동하는 것
<text-align: center> : 글씨 가운데로 옮기기
<font-size: 20px;> : 글자 크기 조절
<height: 70px;> : td 높이 조절
<border: 1px solid black;> 표 줄 색깔

 <table cellspacing="0"> : 칸 붙이는 거
 <caption> 햄버거 비교표</caption>: 제목크키
 </thead> : 제목 소개
 </tbody> : 본문내용
 선택자 : 특정 태그를 지정할 수 있다.
 - class, id, name, tag, > ~
 - class : (점)으로 표시, 중복 사용이 가능하다. 
cursor: pointer; : 마우스 손가락으로 변신
background: 칸 색깔 바꾸기
color : wheat : 글자 색 보이기, 바꾸기
border: 1px solid 
파일 이름 바꾸기 f2
td colspan : 모양 맞추기
class="start" : 지정한 숫자 변하기
cellspacing : 표 칸 조절하기
class : 가능하다 중복이
hover : 마우스가 갔을 때 칸이 색깔이 변하는 것
인라인스타일> 내부스타일 >외부스타일
<td rowspan="2" : 밑에 줄이랑 합친

div.menu = <div class="menu">
inherit : 부모랑 똑같이 간다
div : 항복구분 태그 (공간 구분 태그)
line-height : 글자 높이 조정
display: flex; : (((가로로)) 만드는것
justify-content: space-between : 사이사이 공간을 만들어라
justify-content : center : 텍스트 가운데 공간을 없애고 가운대로 집합
글자 평균크기 : 16
rem : 글자크기 두배 
 글자사이즈:   font-size: 1.5rem; 1=16(크기 지정할수있다)
    background: url(../) 꺼내오는거
    width (가로)  height (세로)
    font-size: 3rem; : 글자크키
    border-radius: 표칸 꼭지점 각도?
    font-weight : : bold 글자 모양 변경

    list-style-type: none; 
    앞에 123 없애는 것
    padding : 0% 때만 앞에 안뛰게 하는 것


<ol>순서 있는 목록 태그가
ul : 순서 없는 목록 태그
</ol>
<ul>
</ul>

position : 위치를 지정하는 속성 고정할수 있는 태그(광고 사이드)
absolute : 절대 주소 기준은 부모 ,합치는것
fixed : 고정된 주소 기준은 왼쪽 / 위쪽 (0.0)
relative : 상대 주소 기준은 자기 자리
top, left, right, bottom 지정 할 수 있다
z-index (레이어 개념) 위/아래 설정(레벨) 가장 위에 올라고 겠다
absolute fixed 설정이 되면 (위치를 지정) 공중에 붕 뜬다
옵솔르트와 픽스드는 높이는 퍼센트로 할수있다
transform: translateX(-50%) width : 150px = 70 
선택자 : class, id
id : #dmfh 표시, 중복 불가능 ( 자바스크립트에서 사용 가능하다)
<div class="skip" onclick="vid.style.display='none'">
    
    
    margin: 0; 바깥 테두리 공간
    list-style: none : li,ol,ul 왼쪽 시작을 없애주는 것
    padding: 0; 안쪽 테두리 공간

    p:
    span : 
    a: 문서를 연결 태그
      - 자동으로 손가락이 나온다
      -밑줄이 그어짐
      -글자색이 파랑
      -인라인요소
     -display: block 인라인요소를 블록으로 바꿔준다
    text-decoration: none : 모든 글자 꾸민 효과를 없애는 것
    <a href="">내용</a>     예 <li><a href=""> Hansot</a></li>
     -<a href="https://www.hsd.co.kr/franchise/hansot_store"target="ch">
     -<iframe name="ch" frameborder="0"></iframe> 이름 즉 네임을 설정을 ch를 해야한다
    ifame : 작은 화면 
    선택자 : class, id, name
    사진이 div에 있으면 div에 hover 를 지정해야 한다
     overflow: hidden : 자식이 부모보다 더 넘지 말라 사진 동영상 등등
     transition: 0.5s :시간을 조절
     transform: scale(1.5); : 커져라 
     transform : 커져라 이동해라 등등 명령할 수 있는 
     font-weight: bold: 글자 굴기 
     <iframe name="ch" frameborder="0" </iframe> 화면속에 화면 띄우는것
     src="https://www.hsd.co.kr/"> 새로고침해도 안없어지게 하는것


     시멘틱태그 : 의미있는 태그들 
     <header> : 제목 태그
     <nav> : 메뉴태그 
     <section> 본문 내용 태그
     <article> 상세 내용 태그
     <footer> 꼬리말 태그(회사주소/전화번호 기타등등)
     <aside> 광고/배너
     
     display 를 쓰면 
     justify 와
     align-items: center: 세로 높이를 센터로 옮겨라 
     display: 

     웹폰트 : 인터넷 상에서 웹아이콘 제공(구글)
     자식 태그에 position을 설정하려면 부모 태그에도 position이 있어야 한다
     (없으면 자식 태그들은 부모를 벗어난다.)
    text-indent : 글자를 이동
      <small> : header제목보다 조금 작은 글씨할때

    position: relative(부모) : position: absolute 이걸 할려면 부모가 잡아줘야한다
     position: absolute(자식) : 하나로 모이게 하는것
     
     animation : 움직임
     -움직임의 시작 : from /0%
     -움직임의 끝 : to 100%
      animation-fill-mode: forwards : 움직임 했다가 마지막에는 멈추는것

     center: 글씨 가운데로
    fontawesome : 이모티콘 다운 받을 수 있는 곳
    overflow: hidden : 지정된 부모의 크기(높이,가로) 넘어가는 글씨는 다 숨기는 것
    relative:
    border-radius: 15px; : 테두리 모서리 조정


     <section>
         컴퓨터(대분류)
          <article>
              프로그램
               <section>
               자바 
                  <article>
                     연산자
                  </article>
               </section>
          </article>
      </section>

      text-indent : 글자를 이동
      <small> : header제목보다 조금 작은 글씨할때


2023.08.03

  javascipt

  alert(내용표시 api) : 내용 표시 명령어
  우주.은하계.태양계.지구.한국.서울.마포구.중앙정보처리학원=10;
  jQuery 사용 
  

 데이터/정보 

  데이터 종류 : 
  원시 데이터 (type) : 더 이상 분해 할 수 없다.
      1.Number : 숫자
      2.string : 문자
      3.Boolean: 명제(true/false)  
      4.undeflned : 값이 지정되닌 않은 상태
      5.Null : 값을 모르는 상태
  오브젝트 데이터형(type) : 원시 데이터의 모임
      1.배열(array)
      2.객체 (object)
      3.클래스

  변수 : 데이터값를 기억하는 임시 기억장소 (let abc-"홍길동";)
  변수 선언법
      1.var : any타입(어떤값이든 저장 가능)
      2.let: 같은 타입 데이터만 입력
      3.const: 값을 고정시킨다.(상수지정)
  변수 만드는 법
      1. 영문자로 시작,$,_(언더바) 시작해야 한다.
      2.변수 사이에 공백 사용불가( ab= c =10;)
      3.특수문자 사용 불가(a?b=10;)
      4.예약어 ( 명령어 ): (for=10;)
      5.변수 작명법 : 의미있는 단어(쇼핑몰 price =danga+su )
                      name= '홍길동",age= 20;
      카멜표기법 : 두 개의 단어로 변수/함수 명을 작성 할 때 두번째 첫 글자는 대문자로 쓴다
                    (cardpoint = 20;) 
     파스칼표기법 : 각 단어 첫 글자를 대문자
                    (Cardpoint = 20;)
      어더스토러 표기법 : 단어 사이에 언더바 넣기
                      (card _point = 20;)






  자바스크립트 기본 문법
  1. 한 문장이 끝나면 ;(세미콜론) 해야 한다.
  2. 대.소문자를 구분 (소문자 기본)
  3. 주석(설명문)
          한 줄 주석://
          여러 줄 주석:/*와 */사이에 있는 것은 실행하지 않음
  자바스크립트 실행 후 html 실행해라

  함수= function: 실행문 (모임) 처리문
   - 괄호가 있으면 함수로 인식 
   alert("알림"), write("출력 내용")


          document.write : 화면에 띄어라

          축약형 수식
          변수 = 변수 + 10;
          증(감)연산자
          count++; //후위 증가 연산자
          ++count   // 전위 증가 연산자



2023.08.04

반목문 : 예제 - 시각적 구현 ( 스타일 )

for(i=1; i<=5; i++) {

    1초기값   2비교값  4증가값


    document.write("<br>자동차-" + i)
    ---------------3실행문
}

연산자 : 산술연산, 논리연사, 관계연산,
산술연산: + ,-  ,/ ,%(나머지연산자)
        10%3...1 9%5...

        엔티티코드 : 기호 명령어 볼 수 있는 사이트
        getElementById: id로 지정해놓을때는 이걸 쓴다(자바스크립트)
getElementsByTagName : 부모안에 자식태그를 지정할때 (자바스크립트)
querySelector:
iumsu에는 .jumsu(class) 태그가 들어감
boolean : 데이터형 명제 ( true/false)
                        true 숫자가 있으면 참,541, -1,-5
                        false, 숫자 0 
if(변수) 
||:or 
&&:And 그리고

 var.let
 const : 정해진 값, 변경 할 수 없는 값
 const  abc=20 pi
 abc=20;
 배열: 같은 타입의 데이터를 순서대로 기억시키는 기억장소의 집합
 [첨자]를 사용한다.(index값을 지정-검색순서 )
 -문자역 배역:[대괄호]사용, 콤마로 데이터를 구분한다.
 const dataA=["국내"] 문자열 배열 선언 초기값

 프로그램 작성 도와주는 프로그램들
 API 
 애플리케이션 프로그래밍 인터페이스
 자바 - 클래스 패키지
 자바스크립트 - 라이브러리(jquery,React), 프레임워크
 jQuery : 

setinterval(함수명,시간) : 일정 시간마다 반복 실행 해 주는 함수
함수 = function = 실행문(가능)
    - 내장 함수 ,사용자정의함수

    2023 08.09
    css: animation: 애니메이션이름, 실행시간 linear infnite

    javascipt : animation( { "대상" : "값" },수행시간);
                animation({"left" :   "-1000px})
                animation({"left" :   "-=1000px})

weight(조건) { // 조건이 만족될 동안 실행
        break; //}
        
        
        
        function(함수-메소드(자바)) : 실행문을 저장한 코드 모임
        -함수 선언
        function 함수명() {
            실행문..
        } 
        function 기능(역할)
        -반복작업을 수행
        -데이터 전달 
        -재활용이 가능
        -프로그램을 삭제,수정,유지보수가 쉽다.

        let str = "abcdefg" //문자역 =배역
        let out = str.replace('c','x');
        console.log( out);
        -내장함수 / 사용자 정의 함수

        함수 호출 
        parijy.dothome.co.kr


    2023.08.16

        java 설치 
        java 호칭
        -JDK : 개발도구
            JRE : 실행 환경
                JVM : 자바가상머신(번역 - 바이트:원도우,리눅스,유닉스)
        -안정적인 버전 : 8,11,17-(21년도)
       
        https://adoptium.net/

        
        클래스 중심으로 처리됨
        정의 : 객체를 생성할 수 있는 형태
        기능 : 속성과 연산구조를 정의
                속성(멤버변수)  : 객체가 갖는 기본값 정의
                연산 (메소드 = 멤버함수)       

        구조 : 속성 : 초기값
               메소드 : 실행함수 
               인스턴스 : 객체의 실체
               접근자 :  PUBLIC,protected, default, private
        클래스
            데이터(배열) + 함수 : 관련되어 있는 데이터
            설계도
            사용자 정의 함수 정의

        java 플랫폼이 os 위에서 실행
            플랫폼 : 프로그램이 동작할 수 있는 실행 환경
            java플랫폼 : java(SE (스탠다드)/EE(엔터프라이즈/ME(모바일)))
            
            JAVA project : 전체작업
                        package : 작업 묶음
                            class : 객체를 만들 수 있는 형태(틀)
                                속성 : 상태값
                                메소드 : 실행(동작,기능)
        -------------------------------------------------------
        class: 객체를 생성 할 수 있는 형태(틀)

        클래스 3가지 구성요소
         -필드(속성) : 클래스에 포함된 변수
         -메소드(method) : 클래스 안에 있는 함수
         -생성자 (constructor) : 객체(인스턴스)가 만들어 질때 초기값 전달

        객체지향 : 객체를 중심으로 프로그램이 실행
        (반대말 <---> 절차형 프로그램 : 위에서 아래로 순서대로 프로그램이 실행)
        객체 : 속성과 메소드를 갖고 있다.
        사람 hong = new 사람();

        클래스 객체명 = new클래스();
        Scanner scanf = new Scanner(System.in)


    public  class     Print 
    -------  ----     -----
    공용    형태(틀)   클래스명
    ※ public  class가 붙어있는 클래스명이 바로 파일명이다.
       하나의 파일에 하나의 클래스가 있다.
       여러개의 클래스가 있을 수이 있다. (public은 하나의 모든 클래스에만 있어야 함)
    출력 명령어의 구성 : java.lang *; 기본 패키지 안 모든 클래스 
    System.  out.   println("ok");
    클래스    필드   메소드

    windo-pret-{auto java} - (EDIT 선택) -Content assist: 밑에서 2번째 a-z
    API 찾아보기 java api
    -----------------
    int : 정수 선언             int int_value = 10;

    string : 문자열 선언,"(쌍따음표)로 묶어주어야 함, 글자들
        String str ="홍길동";
		System.out.printf("\n문자열 값 출력 : %s",str);
		



    char ch = '홍';  // 문자는 한 글자, '(따음표)로 해야만 함
		System.out.printf("\n정수값 출력 : %c",ch);
		System.out.println("---------------------");


    Double dou = 65.748568;    //실수형,출력은 %f 기본 소수점 6자리까지 출력
		System.out.printf("\n실수 갑 출력 : %f",dou);
		System.out.println("---------------------");
		

    Boolean boo = true;    //Boolean 타입(형), 참과 거짓으로 표현, %b로 사용
		System.out.printf("\n참(true)/거짓(fales)값 출력 : %b",boo);

    -----------------
    ctrl + alt + 화살표 아래 : 줄 복사

    System.out.printf("출력양식")
    %d : 정수
    %f : 실수 
    %c : 문자
    %s : 문자열
    %b : 논리

        리터럴 : 표현값(value) -정수, 실수, 문자, 문자열,논리값
            -정수 리터럴 : 10진수, 8진수, 16진수, 2진수
            -실수 리터럴 : 소수점형태, 지수형태, double 타입
        상수 : 정해진 값 final 선언
                대문자 사용
                값이 변하진 않는 수
                다시는 값이 변경할 수 없는 수

        화폐 갯수 출력
        23456원
        만원 2장
        천원 3창
        백원 4장
        십원 5개
        일원 6개

        Scanner 클래스는 java.util 패키지 안에 있다.
        scanf  .next() : 공백 이전까진 입력된 문자열을 읽음
            .nextInt() : 공백 이전까지 입력된 정수 읽음
            .nextFloat():공백 이전까지 입력된 실수 읽음
            .nextLine(): 줄바꿈(엔터) 전까지 쓴 문자열 모두 읽는 메소드
        p496
        java.lang 패키지 내용 : 가장 기본적인 클래스 들이 들어있다.
      - Object : 자바 클래스의 최상위 클래스
                    System, string , Math,Class
        Object 클래스는 객체 만들고 메소드를 정의 했는데 주요 메소드
                string toString() : 객체 문자 정보를 리턴
                int hashCode() : 객체의 해시코드를 리턴
                boolean equals(Object obj) ; 객체의 번지를 비교해서 결과 리턴
        System 클래스 : JVM(자바가상머신)번역(인터프리터)OS 일부 기능 사용
                필드:out(출력-콘솔),    err(에러),  in(키보드 입력)
                메소드
                        exit(int status) : 프로그램 종류
                        currenTimeMills() 현재 시간을 밀리초 단위로 long 값으로 리턴
        string 클래스로 객체를 생성해서 사용(기본적으로 사용 가능)
                메소드
                        append() : 문자열 끝에 추가
                        insert() / delete()
                        toStning() : 문자열을 리턴
                        replace(시작위치, 끝 , 위치 ,문자열) 
        Math : 수학 함수
                    메소드 
                            Math.abs() : 절대값
                            Math.cell(): 무조건 올림값
                            Math.floor() : 무조건 내림값
                            Math.max() : 가장 큰 값
                            Math.min() : 가장 작은 값
                            Math.random(): 난수 발생 ( 0~1 사이의 숫자)
                            Math.round() : 5를 기준으로 반올림값
        메소드(멤버 함수):실행 가능한 프로그램 (기능,동작)
        1.클래스 내부, 외부,생성자 등에서 호출 해야만 실행
        2.클래스 내부에서 호출은 메소드명();으로 호출하다.
        3.클래스 외부에서 호출은 클래스가 만든 객체를 통해서 메소드가 호출(참조변수) 된다.
        4.내부 메소드는 클래스의 멤버함수로 존재한다.


    2023.08.17

        JAVA템플릿 구성(소스파일 구조)
        프로젝트
        패키지  
            클래스
                멤버함수(메소드) 
                멤버변수(속성=필드)
                main()


        클래스
       정의(역할=기능=동작):객체를 생성할 수 있다
        구성:
                멤버변수(속성=필드) : 객체의 기본값
                멤버함수(메소드) : 동작,기능,실행

        ※클래스명의 첫 글자는 대문자로 한다.(System.out.println)()
        변수,메소드명 : 첫 글자는 소문자로 시작
        상수: 변하지 않는 값(상수명은 전체를 대문자)
        public이 붙은 클래스명은 파일이름(.java) 자바 실행파일의 확장자 .class
        일반 클래스는 publid을 쓰지 않는다.

        객체 : 클래스가 생성한 Object로써 메소드를 갖고 있다.
        인스턴스 : 클래스에서 생성된 객체의 호칭(실제값)

        메소드(멤버함수) : 실행 가능한 프로그램을 코드를 갖고 동작을 한다.
                메소드 사용법 : 클래스 내부,(다른 클래스)외부,생성자에서 호출해야만 사용 가능
                               클래스 내부에서는 메소드명();으로 호출된다.
                               클래스 외부에서 호출은 클래스가 객체를 만들어서 객체를 통해서 호출(참조변수)
        
        pubilc : 접근 지정자 중의 하나로 공용으로 사용할 수 있음을 선언
                 public static void main() : static 메모리 영역에 고정(static)되어 누구나(public) 사용가능
                 프로그램은 main()에서 시작해서 main()으로 끝난다. (main 메소드는 Retum 값이 없다.(void))
        
        자바 Base 모듈 : java.lang.java.util.java.text ....
                (프로그램 단위)
        
        java.lang 패키지 안에 있는 클래스 6개 중 3개만 말해보세요 : Object,System,string,Math,Class,래퍼클래스(포장클래스)
         
        System 클래스에 들어있는 필드 3가지 :  System.out , System.in, System.err
        System 클래스 : java.lang 패키지에 들어있는 클래스
        System 클래스에 있는 입출력 메소드 3가지 : out.println, out.printf, out.print
                out.printf : 출력 형식(포멧)의 지시자
                        %d:정수      %f:실수    %c:문자      %s:문자열       %b:논리
                

        자료형 타입 소개 
                기본형
                참조형
        --------------------
                기본형  : int, char, Double, Boolean
                 -정수형 : Byte(1),int(4),short(2),long(8)
                 -실수형 : float(4),double(8)
                 -문자형 : char(2) - 유니코드 : 전 세계 언어들을 표현 가능한 코드
                 -논리형 : boolean(1)     // 참,거짓 (true,false)
        

        API : 애플리케이션 프로그래밍 인터페이스
              -----------           ----------
                응용 s/w              연걸(조작방법)

        자바 API 검색 구글 java api documentation
        -------------------------------------------------
        참조 타입 (reference type)
         -객체 형태로 저장됨
         -실제 값이 저장된 메모리 주소를 저장해서 사용하는 데이터 형태
         -String str= "abcd"; 문자열 참조 타입
         -int arr= (10,20) 배열도 참조 타입
         -기본 자료타입(primitive)을 객체로 취급하기 위해서 사용하는 클래스
         -기본 자료타입(primitive)은 값을 갖는 객체를 생성할 수 있는데 이런 객체를 "표장객체" 라고 함
         배열 안에 들어가는 값은 객체이고 그 안에 들어가는 값을 다루기 위해 참조 타입으로 변환한다.

         래퍼클래스 : 기본 자료타입으로 객체를 생성할 수 있게 만든 참조타입형(8개)
                     래펴클래스는 객체가 기본 데이터 유형을 저장 할 수 있는 특수한 클래스
         
         기본 타입 : 데이터일 뿐 -char       int    double boolean iong    short byte    
         참조 타입 : 객체 생성 가능 -Character Integer Folat Double  Boolean  Long  Byte  class, interface
         int abc = 123;   // 123이 문자이면 "123"

         BigDecimal 클래스 : 소수점을 다루는 연산에 참가(사용)
                            BigDecimal 클래스 java.math 패키지 안에 포함
                            BigDecimal 클래스를 초기화 할때 문자열을 인수 값으로 전달한다.
                            BigDecimal 클래스 문자열 이기에 산술연산이 안된다.
                            BigDecimal 클래스 메소드를 사용한다.
                            BigDecimal 클래스 값을 비교할 때는 compareTp7   

        
        Ascii Clde : 아스키코드
         -7비트로 구성된 코드
         -통신용으로 사용되는 코드
         -모든 문자에 해당되는 숫자가 있다.
         7(삐), 13(엔터), 32(스페이스), 숫자0(48) 숫자1(49)
         대문자 A(95),  대문자 A(90)
         대문자 a(97),  대문자 A(122)
         

    2023.08.18
         클래스 : 
                    정의 : 객체 생성 형태(틀)
                    구성 : 멤버변수,멤버함수
                    ※ 첫 글자 대문자,(필드와 메소드 첫 글자 소문자.)
         객체 : 속성과 메소드로 문제 처리
         인스턴스 : 클래스가 생성한 객체 즉 실제값
         메소드 : 실행 ( 동작, 기능) - 실행 가능한 프로그램을 작성해서 문제 처리됨
         public : 공동선언 
         API : 애플리케이션 (응용s/w/-사용자프로그램) 연결

         자료형 타입
                    기본형(primitive) : 값
                        정수형(byte,short,int,long)
                        실수 (float,double)
                        문자 (char)
                        논리 ( boolean)
                    참조형(reference) : 주소(메모리) 값을 기억하는 자료형
                    
                    참조타입 : 주소값,class , Array,String,Onterface
                        -기본형을 객체로 취급하기 위해 사용하는 클래스들
                        -왜 객체로 취급해야 하나요? 메소드를 사용 할 수 있다.(객체.legnth(),toString())
                        
                        -저장된 값은 주소를 저장
                        래퍼클래스: 기본 자료형으로 객체를 생성할 수 있게 만든 참조타입의 모임 
                                    Character,Inteher,Float,Double,Boolean,Long,short
                        자료형에서 
                        실제값 : value
                        주소값 : address
                        

        BigDecimal 클래스 : 소수점을 다루는 연산 ( 정확한 결과)
        -java.math패키지 안에 있다.
        -전달 인수 반드시 문자열
        -compareTo라는 메소드로 값을 비교

        리마크스
        1.선택 번호는 switch문을 사용

        저장영역
        데이터 영역 : 변수, 로컬변수
                    {} 끝나면 사라집

        static 영역 : 정적 영역
                    프로그램 끝날때 까지 기억
        힙영역 : 동적 영역,배열
                    필요에 따라 저장,


    2023.08.21
        
        Static영역(메소드영역): 프로그램 시작 ~ 끝 
                               클래스가 로딩
                                    클래스 변수,상수,생성자,메소드
        Stack 영역 : 스코프(중괄호= 블록) 내용(지역변수,매개변수,기본데이터형)
                    메소드가 종료되면 메모리에서 사라짐
                    스레드 객수마다 생성
        Heap(힙) 영역 : 동적할당(실행하면서) 사용되는 영역
                        참조형(배열, 스트링, 인스턴스)등이 저장되는 공간
                        (단 레퍼런스 변수는Stack에 저장됨)
                        메모리에 계속 남아 있다가 사용하지 않으면 Gc(가베지콜렉터)가 삭제한다.
        --------------------------------------------------------------------------------
        배열(Array) : 같은 타입의 데이터를 순서대로 저장하는 기억장소
        배열 선언: 참조형 변수 선언 
        배열 인덱스(첨자): 배열 안에 요소들이 갖는 순서번호
        인덱스 번호 0~4까지(0부터 시작함) 
          예)int[]  jumsu = new int[5];  //배열선언
             int [] jumsu = { 50,60,70,80,90 }      
                배열 지정하면 값을 넣는 것을 초기화
                배열의 크기는 변경 할 수 없다.()

        ==============================================================
        main 메소드에서 시작해서 main 메소드에서 끝난다.
        public static void main(String[] args) : 1개만 존재

        static 있다 : 클래스 멤버 (static 영역 - 정적) - 모든 객체에서 사용
        static 없다 : 인스턴스 멤버 (stack영역)        - 객체에서만 사용

        ※ 클래스 멤버는 인스턴스 메소드에서 사용 가능하다
        인스턴스 멤버는 객체를 생성한 후에 객체를 통해서 사용 가능하다

        static : 공동 정적 변수(static 영역 저장)
        1. 클래스 멤버가 된다.
        2. 모든 객체에서 공통적으로 사용 가능
        3. 모든 인스턴스에서 공통적으로 사용 하려면 static 붙인다.
        4. static이 붙은 멤버들은 객체를 생성하지 않아도 사용 가능
        5. static이 붙은 멤버들은 클래스(프로그램) 메모리로 읽어 들일 때  자동적으로 생성
        6. 클래스 영역에서는 멤버들만 쓸 수 있다.(일반 수식,값 변경 등은 멤버함수에서 한다.)

            내부 클래스 만드는 이유: 중요한 것이니까 
            좋은 점이 많으니까
            1. 객체 생성 없이도 (멤버변수/멤버함수) 사용 가능
            2. 상위 클래스의 속성/메소드 등을 상속 받는다.(쉽게 사용)
            3. 내부클래스는 상위 클래스 안에서만 사용되기 때문에 보안(캡슐화)이 가능하다
            4. 내부클래스 앞에 public,private,protected 모두 붙일 수 있다.
             (외부클래스는 pubilc만 올 수 있다.)
            5. 간단,복잡성,코드 길이도 줄어든다.
            6. 내부클래스는 static을 붙여준다.



             상위 (부모=외부 클래스)


            inter_tra
            멤버함수 run
            멤버변수 speed

    2023.08.22
        생성자 : 객체가 만들어 질 때 초기값을 위해 실행되는 (특별한)메소드
            객체가 생성될 때 자동으로 호출되는 메소드
            생성자 안에는 값을 초기화 하는 코드 있다.
            생성자 안에서 변수를 선언하지 않는다.

            생성자의 이름은 반드시 클래스 이름과 동일해야 한다.
            생성자는 메소드이므로 여러 개 작성(오버로딩)
            생성자는 new 연산자를 통해 객체를 만들 때 한 번만 호출된다.
            생상자는 리턴 타입이 없다.(값을 리턴하지 않는다.)

            매개 변수 (전달인수)와 실행코드가 없는 단순 생성자를 "기본 생성자"라 한다.
            디폴트 생성자라고도 한다.
            기본 생성자는 조건에 따라 자동으로 생성되기도 하고 직접 입력 해줘야 한다.
            자동생성 : 생성자가 하나도 없을 때 컴파일러가 자동으로 생성한다.
            생성자가 하나라도 있을 경우 기본 생성자는 자동으로 생성되지 않는다.


            this : 자신 (Class)

            Person 클래스에서 hong을 소개하는 생성자를 작성
                            lee 소개하는 생성자를 작성


    2023.08.22

        생성자 : 인스턴스 변수를 초기화(값)
        1.객체를 새로 만들 때 한 번만 실행
        2.왜 하는가?
            - main()메소드를 간단 명료하게 제작(편하다)
            -메모리 할당을 예약(참조변수)
            -네트워크 관련 작업 등 여러가지 기능
        3.생성자는 어떻게 만들어지는가?(규칙)
            -(메소드인데)클래스 이름과 같아야 한다.
            -new를 통해서 만든다.
            -리턴값이 없다.(void 안 쓴다.)
        4.모든 클래스는 생성자가 호출한다.(컴파일러가 자동으로 만든다.)
        5.기본 생성자 = 디폴트 생성자
            -매개변수가 없다.(전달값이 없다.)
            -클래스이름(); 자동으로 만들어준다.
            -사용자가 직접 만들어 놓을 수도 있다.
        6.생성자는 형태가 여러가지 이다.

        this : 참조변수,인스턴스,생성자에서 사용/ static(클래스)에서는 사용불가
        this() 생성자, this참조(주소)변수 (자기 자신을 가르친다.)

        생성자의 목적
        1.객체가 생성될 때 인스턴스 멤버변수를 초기화
        2.객체가 생성되는 순간 자동으로 호출된다.
        3.생성자 안에는 변수를 선언하지 않는다.
        4.생성자 이름은 클래스 이름과 동일하게 작성해야 한다.
        5.생성자는 메소드이므로 여러 개 작성(오버로딩) 할 수 있다.
        6.값을 리턴하지 않는다.


        기본 생성자
        1.매개변수가 없다.(하는 일이 없다.)
        2.자동 생성 또는 직접 만들기도 한다.
        3.생성자가 하나라도 존재하면 기본 생성자는 자동으로 만들지 않는다.


        상속 : 
        1.부모 클래스의 자원을 자식 클래스에서 사용 가능
        2.두 클래스 관계를 설정하는 것
        3.물려주는 쪽은 하나는 부모클래스 되고 받는 쪽은 자식 클래스가 된다.
        4.extend 키워드를 사용한다.
        5.부모 클래스 = 상위클래스=super클래스=기초클래스 : 멤버를 물려준다.
          자식 클래스 = 하위클래스=sub클래스 : 멤버를 물려 받는다.
        6. 자식클래스 ---> 부모클래스 (클래스 다이어그램)
        ※super(부모 클래스를 지칭한다.)
                자식클래스의 생성자의 매개변수가 있는 경우 super(매개변수) 생성자를 찾아간다.
                부모클래스의 생성자가 매개변수가 있는 경우에 사용한다.
                


        7.객체 생성시 찾아가는 생성자는 부모 생성자를 먼저 찾아간다.
            -자식 생성자에서 오버로딩 할때 부모 생성자가 오버로딩에 해당하는 생성자가 없으면 에러
            ( Hong(int age))-자식 생성자 매개변수는 1개
              부모생성자에서도 매개변수 1개짜리가 존재하면 문제없다.
                        (생성자가 아예 없으면 문제가 없다.-자동 생성이니까)
        가전제품: Element 클래스
                         weight=100
                         power=220
                         price=300

        컴퓨터 : Com 클래스 

    

    2023.08.24

        1.부모클래스의 모든 자원을 물려받는다.(private)
        2.두개의 클래스 간의 관계를 설정
        3.상속 받은 내용을 재정의 (오버라이딩) 할 수 있다.
        4.클래스-다이어그램 : 클래스와 클래스의 관계를 도형으로 그림
            (부모 클래스) <------(자식 클래스)
            클래스이름 - 멤버변수/멤버함수
        5.부모클래스 = 상위클래스 = super클래스 = Base(기초) 클래스 : 자원(멤버변수 / 멤버함수) 주는 쪽
            자식 클래스 = 하위클래스 = sub클래스 


        이론 = 개념실습 = 응용실습
        -------------    -------
        객체가 생성 될 때 생성자가 자동으로 호출된다.
        기본생성자(디폴트생성자) : 매개변수가 하나도 없는 생성자
        매개변수가 있는 생성자를 갖은 객체가 상속(extends)이 되면 반드시 super를 호출해야 한다.
        super를 호출해야 하는 이유 : 1. 안하면 에러가 난다. (자기방에 들어가려면 현관(부모클래스)을 열고 들어가야 한다.)
                                    2.super(부모클래스)에 자식 클래스에서 만든 생성자(매개변수 있는)와 같은 타입의 부모 클래스 생성자가 있어야 한다.


        오버라이딩 
         1.상속에서 생성된다.
         2.이름은 같고 내용만 다르다(재정의)
         3. 

         다형성 : 부모(자식)클래스의 결정에 따라 다양한(메소드 선택결정) 선택을 할 수 있다.
                  --------------------
                  부모 타입(클래스)속에 해당 메소드가 있느냐 없느냐에 따라 사용하느냐를 선택 할 수 있는 상태

         다형성의 대상 : (인스턴스 - 상속)의 메소드
         다형성 필요성 : 선택의 범위가 넓다.

         ※ 오버로딩 : 메소드의 매개 변수에 개수(형태,순서)에 따라 다르게 처리
            오버라이딩 : 상속 받은 메소드를 재정의(내용만 고친다) 하는 것(메소드 이름, 메소드 매개변수 바꾸면 안됨)
             

    2023.08.25
         객체(Object)지향프로그램(Oriented) 프로그램(Pregraming) : OOP
         OOP 사용 목적 (이유) : 확장성, 재활용, 관리가 쉽다   

         클래스 : 객체를 생성
         객체 : Object (클래스가 만들어 낸 Object다.)
         인스톤스 : 속성과 메소드를 갖고 있는 실제값
         속성 : (상태)값
         메소드 : 실행,동작,기능
         static : 공유 할 수 있는 고정된 값.(static가 붙은 클래스 멤버)


         생성자 : 객체가 생성 될 때 호출되는 (특별한) 메소드
         생성자의 목적 : 객체가 생성 될 때 초기화(값을 전달)
         1. new 키워드를 사용한다.
         2. 리턴값이 없다.(void 쓰면 안된다.)
         3.생성과 초기화를 동시에 한다.


         public : 공용(공개)
         private :  비공개
         protected ; 상속 범위 공개 
         default ; 같은 패키지 내 공개

         상속 : 부모클래스의 멤버를 자식클래스가 사용 가능 (extends)

         다형성 :  상위클래스가 하위클래스를 선택한다. (부모 클래스의) 메소드 선택 가능
                  부모클래스 = 자식클래스
                  
            sebaek@gmail.com

            System.identityHashCode(c); : 주소값을 보여주는 시스템

            hashCode() : 문자열이나 정수 등등 그 값에 숫자로 나타내여서 비교할때 숫자로 비교하니 편하게 비교할 수 있다.



             toString : 메서드는 객체가 가지고 있는 정보나 값들을 문자열로 만들어 리턴하는 메소드 입니다.
            getter 그 값을 반환하는 메소드
            settters 변수 값을 지정해주는 메소드
           

           private field : 속성 

           pubilc method : 기능
           
           private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;

    }

            메소드
           hashCode : 해시코드를 간단하게 말하면 해시 알고리즘에 의해 생성된 정수 값 
           hashcode()는 객체의 hashCode를 리턴한다.hashcode는 일반적으로 각 객체의 주소값을 변환하여
           생성한 고유한 정수값이다.
            equals : 오브젝트와 다른 오브젝트랑 같은지 다른 지 알려준다 같이 같은면 ture라고 나온다


            new A();     = Ctrl + A/t + v 하면 = 데이터 타입 변수 생성
            Ctrl + A/t + t  = surround 생성
            Ctrl + d : 줄에 있던 코드들이 밑으로 복사가 됩
             shift + A/t + 화살표 : 클릭했던 줄이 이동함





        09.06

        replace : 함수는 자신이 바꾸고 싶은 문자로 문자열을 치환시켜주는 기능을 한다
            String a = "화려강산 대한사람"
            a = a.reference("대한", "민국");
            System.out.printnl(a);
            //결과값 : 화려강산 민국사람

        replaceAll : 문자열 중에서 지정된 문자열 (regex)과 일치하는 것을 새로운 문자열(replacement)
                     로 모두 변경한다.

        wrapper class :기본 자료타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을
                        래퍼 클래스(wrapper class)라고 한다
                        기본타입을 감싸고 있는 클래스

    
    // 기본타입(primitive type) : byte,short,int , long, float, bouble,char,boolea
    // 래퍼 클래스 (wrapper class) : Byte, Shot, Integer,Long,Float,Double,Character,Boolean

    // boxing(박싱) : 기본타입-> 참조타입
    // unboxing(언박싱) : 참조타입 -> 기본타입


        //Arrays : 배열을 다루는 메소드들 있음
        //equals : 두 배열이 같은지
        //fill : 배열을 특정 값으로 채우기
        //sort : 배열 정렬
        //binarysearch : 특정 원소의 위치 찾기
        //toString : 문자열로 변환

        컬렉션 : 객체를 담고 있는 객체

        % : 나머지
        
        2의 배수 하고 싶으면
        
        class Solution 
    public int solution(int n) {
        int answer = 0;
        for(int i =0; i<=n; i++) {
           if(i%2==0) {
              answer+=i;
           }
        }
        return answer;
    }




        지네릭스 : 컴파일시 타입을 체크해 주는 기능
        ArrayList : 단순 배열은 객체 생성시 사이즈를 지정하지만,  ArrayList는 사이즈의 제한이 ㅓㅇㅇㅄㅎ다
                    배열과 같이 순서를 가진다
                    데이터를 추가할 때 add()와 addAll()이 있다.
                    List를 만들 때 내부적으로 배열을 사용하는것
        add() : 연결리스트에서 맨 뒤에 새 노드를 연결시키는 것과 같다. -> 뒤쪽으로 데이터가 쌓이고, 순서를 가진다
        addAll() : ArrayList에 다른 ArrayList의 데이터를 통째로 붙이기 위한 메서드이다.
                   인자로 Collection 객체를 받고 그 Collection 에 있는 아이템들을 리스트에 모두 추가한다.

        int와 Integer 차이점
        int : 변수의 타입(data type) 이다.
        자료형 : 산술 연산 가능함
                 null로 초기화 불가

        Integer : 래퍼 클래스 : unboxing 하지 않을 시 산술 연산 불가능함
                                null값 처리 가능 
                기본형을 객체로 다루기 위해 사용하는 클래스들을 래퍼 클래스 라고 한다
                그리고 Integer는 int의 래퍼클레스 라고 할 수 있다.

                형변환 : 변수의 타입을 다른 타입으로 변환하는 것이다
                        double d = 85.4;
                        int score = d; X안된다
                        int score = (int) d; // 강제 형변환

        Iterator : 컬렉션에서 요소를 제어하는 기능
                    next() 및 previous()를 써서 앞뒤로 이동하는 기능
                    hasNext()를 써서 더 많은 요소가 있는지 확인하는 기능

        배열의 인덱스 각 요소에 자동으로 붙는 번호

        
        LIFO  : 라스트 인 퍼스트 아웃 
            push : 
            pop : 마지막 메소드를 호출 ( 없어지는 것)
            peek : 마지막 아이템을 살펴보는 것 (없어지지 않는 것) 

            항등원 : 어떤 연산을 했을 때 자기 자신이 나오게 하는 것
            역원 : 어떤 연산을 (+,-등등)을 했을 때 항등원이 나오게 하는 것
           


           
        2023.09.13

    
             filter : 중개연산을 수행하는 메서드
                      주어진 조건자와 일치하는 스트림의 요소로 구성된 스트림으로 반환

            Collection 의 합을 구하는 방법은 reduce 와 sum 두 가지가 존재합니다.
                단, Stream 에서 sum() 을 사용하려면 
                IntStream, LongStream, DoubleStream 와 같은 기본형 (Primitive Type) 특화 스트림을 사용해야 합니다.
                그래서 보통 mapToInt, mapToLong, mapToDouble 같은 
                메소드로 스트림을 변환시키고 사용합니다.

                reduce : reduce(초기값, 연산) 형식으로 사용합니다.
                        초기값부터 시작하여 각 원소를 차례대로 순회하며 연산을 수행합니다.
                        이전 연산의 결과를 다음 초기값으로 넘기면서 연산의 결과를 누적해서 총 결과값을 구하는 메서드입니다.
                        int sum = Stream.of(1, 2, 3).reduce(0, Integer::sum);

                      sum() : Stream 의 총합을 구하는 메서드입니다.
                              기본형 특화 스트림에서만 사용 가능합니다.
                              int sum = Stream.of(1, 2, 3).mapToInt(e -> e).sum(); 
                                이 스트림에 있는 요소의 합계를 반환합니다. 
                                이는 축소의 특별한 경우이며 다음과 동일합니다.

                abstract : 추상 메소드(abstract method)란 
                            
                            
                            
                            
                            
                             수 있는 메소드를 의미합니다.

                collect : collect()는 Stream의 데이터를 변형 등의 처리를 하고 원하는 자료형으로 변환해 줍니다.

                stream : 컬렉션(Collection)을 기반으로 하는 스트림을 생성하는 메소드입니다.
                         데이터를 처리하고 변환하는 강력한 방법을 제공한다

                toList() : 스트림에서 필터링,매핑 또는 다양한 연산을 수행한 후 그 결과를 리스트로 저장하고자 할때
                           유용하게 사용됩니다.

                forEach() : 스트림의 각 요소를 반복하면서 해당 요소를 출력하는 방법 중 하나이다.
                            예 : List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
                                 numbers.stream().forEach(System.out::println);
                                 
                                 1
                                 2
                                 3
                                 4

        2023.09.14

        exception : 프로그램 실행 중 발생할 수 있는 정산적인 범위를 벗어난 경우에 처리를 하기 위한 방법

        try : try 안에서 오류가 뜨면 catch넘어가서 실행을 시킨다
        반대로 try 안에서 true면 실행이되고 catch 는 넘어간다 (실행이 안된다)
        
        e.printStackTrace() : exception 이 발생한 이유와 위치는 어디에서 발생했는지
                              전체적인 단계를 다 출력합니다 위치와 정확하게 알려주어서 어디서 에러가 
                              발생하였는지 빠르게 파악이 가능하다

        finally :
            //finally block;
            //exception 발생과
            // 관계없이 실행되는 block
            System.out.println("꼭 실행 코드");
            retrn 문을 만나도 실행이 된다


        ArrayIndexOutOfBoundsException : 잘못된 인덱스를 사용하여 배열에 액세스했음을 나타내기 위해 발생합니다. 
                                         인덱스는 음수이거나 배열 크기보다 크거나 같습니다.
                                         즉 : 잘못된 인덱스일때 실행 되는 것


        NumberFormatException : 애플리케이션이 문자열을 숫자 유형 중 하나로 변환하려고 
                                시도했지만 문자열에 적절한 형식이 없음을 나타내기 위해 발생합니다.
                                즉 : 문자열이 숫자 유형으로 변환하려고 할때 오류이면 실행되는 것


        Integer.parseInt : 인트로 분석해라 -> int value = Integer.parseInt(array[i]);
                                            (문자열을 숫자유형으로 바꿔라)

        에러 = 사용자가 어찌할 수 없는 문제
        예를들어 java명령어 자체에 오류가 있는 경우

        예외 = 사용자가 코드를 작성하면서 생긴 문제
        unchecked 랑 checked가 있는데
        un은 굳이 체크할 필요가 없음.
        체크를 안해도 실행됨.
        실행중에 예외가 발생하면 런타임예외
        RuntimeException은 unchecked exception 굳이 체크안해도 실행되는 예외

        checked exception은 반드시 체크를 해야됨
        체크하는 2가지 방법
        직접 try catch문을 사용하여 잡는법
        throws를 통해 상속받을 class안에서 try문을 사용하게 하는법

        throw : 예외를 강제로 발생시키는것이 바로 throw 입니다. 코드를 작성하는 프로그래머가 강제로
                예외를 발생시키는 것입니다.


          자바에서는 데이터를 외부에서 읽고 다시 외부로 출력하는 작업(입출력)에 스트림(Stream)을 사용함
          스트림은 단일 방향으로 연속적으로 흘러가는 것을 말하며, 데이터는 출발지에서 나와 도착지로 들어간다는 개념
          스트리밍의 특성이 단방향이므로 하나의 스트림으로 입력과 출력을 모두 할 수 없음
          프로그램이 네트워크상의 다른 프로그램과 데이터 교환을 하기 위해서는 양쪽 모두 입력 스트림과 출력 스트림이 따로 필요
          입출력 작업의 예: 키보드, 파일, 네트워크에서 입력과 모니터, 파일, 네트워크의 출력 
          프로그램이 출발지냐 또는 도착지냐에 따라서 스트림의 종류가 결정
          프로그램이 데이터를 입력받을 때는 입력 스트림(InputStream)
          프로그램이 데이터를 보낼 때는 출력 스트림(OutputStream)

    2023.9.18

     // %s : 문자열 출력
        System.out.printf("문자열:%s%n", "java");
    // %d :  정수 십진법 출력
        System.out.printf("정수 : %d%n",99);
     //argument_index$
        System.out.printf("정수2:%2$d%n정수1:%1$d%n", 100, 200);
        System.out.printf("정수:%1$d%n", 9, 8);
        System.out.printf("정수:%2$d%n", 9, 8);

        FileReader : 파일을 불러올 수 있는
        BufferedReader : 파일도 불러올 수 있지만 속도를 빨리 할 수 있는 기능이 있다

        join() : 메소드는 실행중인 쓰레드를 강제로 실행 대기(lock) 
                 상태로 변하게 한 뒤 특정 쓰레드가 실행되고 종료 될 때까지 기다리게 할 수 있다.

    

    어노테이션 : 코드에서 @으로 작성되는 요소를 어노테이션이라고 한다.(주석)


    enum
reflection
annotation

https://example.com /over/there ?name=ferret
         서버주소       경로      쿼리스트링(파라미터) request parameter

커리스트링:   이름 = 값 =으로 구분되어 있다.
             이름 값 쌍은 & 으로 구분되어 있다.
        
        
        모르는 단어들 :
             request.getParameter
             request : 리퀘스트 : 요청
             WebRequest
             require : 리콰이어드 : 요청된 : 
             



    @RequestMapping("sub2")
    public void method2(WebRequest request) {
        String name = request.getParameter("name");
        String address = request.getParameter("address");

        System.out.println("name = " + name);
        System.out.println("address = " + address);
        }
        위에 있는 코드를 밑에 있는 코드로 바꿀수 있다
        간편해 졌다.

    @RequestMapping("sub8")
    public void method8(@RequestParam("address") String adderess,
                        @RequestParam("married") Boolean married,
                        @RequestParam("age") Integer age) {
        System.out.println("adderess = " + adderess);
        System.out.println("married = " + married);
        System.out.println("age = " + age);
        }

            @RequestMapping("sub1")
    public void method1(@RequestParam String name) {
        System.out.println("name = " + name);
        }
        @RequestMapping("sub3")
    public void method3(String name, Boolean married) {
        System.out.println("name = " + name);
        System.out.println("married = " + married);
        }


        value = "age", required = false 로 구분할 수 있다 맞으면 age를 출력하고 틀리면 false로 출력
        value = "age",defaultValue = "10" Integer age

             required : 파라미터가 호출이 됐는지 안된는지
             defaultValue : 파라미터가 생성이 됐는데 작성이 안됐을때

        프로그램을 실행 될려면  쿼리파라미터와 메소드명과 매치가 되어야 한다




        @NoArgsConstructor : 파라미터가 없는 (기본생성자)를 생성한다.

        
        @RequiredArgsConstructor : final 필드를 파라미터로 받는 생성자 생성
        @AllArgsConstructor : 모든 필드를 파라미터로 받는 생성자 생성
        @DATA : get,set ToSTring 다 만들어주는 생성자



        @Controller
        @RequestMapping("main8")
        public class Controller08 

        @RequestMapping("sub1")
    public void method1(Model model) {
        model.addAttribute("attr1", "soccer1");}
        <h1>${attr1}</h1>

        프로그램 실행 시킬때 addAttribute(String object)의 String 을 view에서 <h1>${attr1}</h1>
        불러오면 된다.
        view프로젝트랑 파일을 만들때 main8프로젝트로 해야하고 sub1파일로 <h1>${attr1}</h1> 작성해야한다.





       


     String[] myname = {"내이름은","한","의","혁"};
        String[] you = {"1082cubi", "한메일"};
        String[] her = {"일산"};
        model.addAttribute("myName",myname);
        model.addAttribute("yourEmail",you);
        model.addAttribute("herAddress", her);
        
        순서를 먼저 배열을 지정을 하고 호출을 해야한다
        
     model.addAttribute("myName",new String[]{"lee", "kim"});
     이렇게 줄일수가 있다 객체를 생성해서

      model.addAttribute("list1", List.of("호날두", "메시"));
      또는 List를 이용해서 배열을 할수 있다 
      new String[] {}
      List ()
      
      var :
      var map3 = Map.of("1st", "hamburger", "2nd", "pizza");
      Map이라는 타입이 확실이 있으니까 var를 쓸수가 있다
       String[] you = {"1082cubi", "한메일"};
       var you = {"1082cubi", "한메일"};    //이건 오류가 난다 var 가 확실한 데이터 타입을 모르기 때문이다
        var her = new String[]{"일산"};     // new String을 붙임으로써 String 타입인걸 알았으니까 var를 쓸수가 있다

        jsp standard tag library
        (jstl)



EL 표기법
${ }

expression : 표현
language : 언어        
      
        begin과 end 포함해서 반복 end 는 begin보다 커야함 begin은 0보다 크거나 같아야함

        <c:forEach begin="0" end="2" var="num">
        <li>num : ${num}</li>
        </c:forEach>        : 숫자를 반복할려고 하고 var는 숫자를 반복할수있는 변수를 정했고
                              결과는: num: 0
                                     num: 1
                                     num: 2
        

  <c:forEach items="${names}
        items 는 namas를 가져오는 문법이다
        <c:forEach items="${myList}" var="i">
        <li>cars: ${i}</li>
        </c:forEach>    :  itmes는 가져오는 문법이다 그러므로 myList정보를 가져왔고 var="i"변수를 지정한것이다



    <a a1=""> : 태그라고 부르고 그 안에서 사용되는 애들은 attribute임.
        ex) a태그의 a1 attribute
        ex) <pig eat="" run=""> pig태그, eat이랑run은 attribute

    varStatus : var의 상태들을 알려주는 attribute

    varStatus가 가지고 있는 메소드는
    count, index, current, first, last등등 이 있음

    count : var가 몇번 시행 됐는지 알려주는 메소드
    index : 시행된 var가 몇번 index인지 알려주는 메소드
    current : 현재 var에 저장된 값을 알려주는 메소드
    first : 현재 var가 첫번째인지 논리값을 알려주는 메소드
    last : 현재 var가 마지막인지 논리값을 알려주는 메소드
    
    <c:forEach begin="4" end="7" var="i" varStatus="status"></c:forEach>
    
    1번 시행하면 i는 0
      status.count = 1
      status.index = 0
      status.current = 4
      status.first = true
      status.last = false
    2번 시행하면 i는 1
      status.count = 2
      status.index = 1
      status.current = 5
      status.first = false
      status.last = false
    3번 시행하면 i는 2
      status.count = 3
      status.index = 2
      status.current = 6
      status.first = false
      status.last = false
    4번 시행하면 i는 3
      status.count = 4
      status.index = 3
      status.current = 7
      status.first = false
      status.last = true







     단축키 : shift + shift(빠르게 연속두번) : 파일 찾는것
             원도우 + .  : 이모티콘
             intellij java 단축키
             ctrl + alt + v : 변수 생성
             ctrl + alt + t : surround 생성
             ctrl + alt + n : 중복 되는 변수 하나로 묶기
             ctrl + shift + t : test 생성
             ctrl + alt + shift + t : 리펙토리 메뉴
             ctrl + b : 현재 커서에 있는 맴버가 생성된 파일로 이동
             ctrl + alt + 좌,우 방향키 : 이전에 보고있던 파일로 이동
             ctrl + shift + f10 : 현재 class의 main메소드 실행
             ctrl + f10 : 가장 최근에 실행한 main메소드 실행
             shift + f6 : 맴버의 이름 변경
             ctrl + shift + f12 : 모든 윈도우 창 닫기

        <h4>+,-,*,/,%</h4>
<hr>
<p> a: 3 b :5 c : 8 d : 9</p>
<p>${a} + ${b} = ${a+b}</p>
<p>${c} + ${d} = ${c+d}</p>

<h5>-</h5>
<p>${a} - ${b} = ${a - b}</p>
<p>${c} - ${d} = ${c - d}</p>
<h5>* :곱하기</h5>
<p>${a} - ${b} = ${a * b}</p>
<h5>/ : 나누기</h5>
<p>${a} - ${b} = ${a / b}</p>
<p>${c} - ${d} = ${c / d}</p>
<p>${a} - ${b} = ${a div b}</p>
<p>${c} - ${d} = ${c div d}</p>

<h5>% : 나머지 연산(modulo,reaminder)</h5>
<p>${b} % ${a} = ${b%a}/p>
<p>${c} % ${a} = ${c%a}/p>
<p>${d} % ${a} = ${d%a}/p>
<p>${b} % ${a} = ${b mod a}/p>
<p>${c} % ${a} = ${c mod a}/p>
<p>${d} % ${a} = ${d mod a}/p>

<h5>()< : 우선순위 높음</h5>
<p>${a * b - c}</p>
<p>${a * (b - c)}</p>
<p>${(a * b) - c}</p>
구구단 2부터 9까지
<c:forEach begin="2" end="9" var="i">
        <c:forEach begin="1" end="9" var="j">
        <p>${i} X ${j} = ${j*i}</p>
        </c:forEach>
    </p>
</c:forEach>
구구단 9부터 2까지
<c:forEach begin="0" end="7" var="i">
    <c:forEach begin="1" end="9" var="j">
        <p>${9-i} X ${j} = ${(9-i)*j}</p>

    </c:forEach>
    </p>
</c:forEach>
<h4>||</h4>
파이프

if와 not 으로 할 수 있다 자바에서는 if 와 else로 구분되었다.
<c:if test="${param.name eq 'son'}" var="isSon">
    <p>hello son</p>
</c:if>
<c:if test="${isSon}">
    <p>여전히 son</p>
</c:if>
<c:if test="${not isSon}">
    <p>son이 아님</p>

<c:if> 태그에 사용될 수 있는 속성은 다음 세 가지 입니다.
    - test : 필수 속성으로 속성값으로 EL 비교식을 가집니다.
    - var : 조건 결과를 저장할 변수를 지정합니다.
    - scope : 조건 결과를 저장할 변수의 저장 scope을 지정합니다.
    <c:if test="${name eq '홍길동'}" var="nameHong" scope="session">
    </c:if>

<c:choose> 태그는 조건에 따른 여러곳으로 분기 가능하고, 
    조건이 맞은 것이 없을 경우 기본 분기를 제공할 수 있습니다.

    <c:choose>
    <c:when test="${name eq '김철수'}"> ... </c:when>
    <c:when test="${name eq '박영희'}"> ... </c:when>
    <c:otherwise> ... </c:otherwise>
    </c:choose>
    위 코드는 이름이 "김철수", "박영희" 일 경우 분기 하고 그 외의 경우에는 
    <c:otherwise> 로 분기 합니다.


   foo://example.com:8042/over/there?name=ferret#nose
     \_/   \______________/\_________/ \_________/ \__/
      |           |            |            |        |
   scheme     authority       path        query   fragment




1번 : 먼저 Controller12에와서 실행 시킨다 sub3이기때문에 그와 연결된 jsp에간다. 
    Controller12          
    @RequestMapping("main12")
    @RequestMapping("sub3")
    public void mathod3() {
    }

2번 : sub3 jsp에 오면 form안에 있는 것들을 먼저 실행한다.첫번째 위치한 text에는 name라는 곳에 저장되고 두번째test는 age곳에 저장이 된다
     그리고 전송버튼을 눌렀을때 그제서야 form이 실행이 되서 main12/sub4에 이동하게 된다
    @RequestMapping("sub3")
    public void method3() {
    }
    <form action="/main12/sub4">
        <input type="text" name="name">
        <br>
        <input type="text" name="age">
        <br>
        <button type="submit">전송</button>
    </form>


    
3번 : 다시 sub4와 연결된 Controller12로 돌아와서 실행을 시킨다. sub3에서 값을 받아온 name과 age는  @RequestParam("name") @RequestParam("age") 으로 받고 
        String name,Integer age 지정해서  model.addAttribute("message", name + "과 " + age + "를 저장함");      
        System.out.println("Controller12.method4"); 이것은 콘솔에 잘 나오는지 테스트하기 위함이다
        에 들어가는 name과 age로 들어간다
    Contrlooer12
    @RequestMapping("sub4")
    public void method4(
            @RequestParam("name") String name,
            @RequestParam("age") Integer age,
            Model model) {

        System.out.println("Controller12.method4");
        System.out.println(name + "과 " + age + "를 저장함");

        model.addAttribute("message", name + "과 " + age + "를 저장함");
    }

4번 : "${not empty message}" -> message안에 값이 들어있을때 실행을 하는 것. 순서대로 p태그를 실행을하고 <a href="/main12/sub3">새 이름과 나이 등록하러 가기</a> 것은
        a태그는 누르면 이동하는 것이므로 다시 main12/sub3으로 간다 즉 1번째로 다시 돌아가는 것이다
    body>
        <c:if test="${not empty message}">
            <p>${message}</p>
        </c:if>
        <a href="/main12/sub3">새 이름과 나이 등록하러 가기</a>
    </body>
   


    
2023.09.26
    @RequestMapping("sub3")
    public void method3(
        String param1,                      
        Integer param2,
        String param3,
        LocalDate param4, //날짜
        LocalDateTime param5  //날짜 시간
//        @RequestParam("param1")String param1,
//        @RequestParam("param2")Integer param2,
//        @RequestParam("param3")String param3,
//        @RequestParam("param4") LocalDate param4, 
//        @RequestParam("param5") LocalDateTime
        // 쿼리스트링의 이름이랑 메소드 파라미터의 이름이 같을 때 생략이( @RequestParam("param1") 쿼리스트링의 이름) 가능하다 
           하지만 생략이 안되는 것도 있다.
    ) 

    @RequestMapping("sub5")
    public void method5(String userId,
                        String userEmail,
                        LocalDate birthDate,
                        @RequestParam(value = "hobby", required = false) String[] hobby
    ) {
        System.out.println("userId = " + userId);
        System.out.println("userEmail = " + userEmail);
        System.out.println("birthDate = " + birthDate);
        Arrays.stream(hobby).forEach(System.out::println);
    }

    @RequestMapping("sub6")
    public void method6(MyDto11 user) {
        System.out.println("user = " + user);
    }

    //LocalDate : 날짜 타입 클래스

    get 방식 : 주소에 쿼리스트링으로 붙어서 전송
        1. 브라우저 주소란에서 볼 수 있음
        2.길이의 제한이 있음

    post 방식 : 요청 본문에 붙어서 전송
        1.브라우저 주소란에서 볼 수 없음
        2. 길이의 제한이 없음

    //@RequestMapping(value = "sub5",method = RequestMethod.GET)
    @GetMapping("sub5") 
    public void method5(){}
    해석: //@RequestMapping(value = "sub5",method = RequestMethod.GET) 이 래핑을
          @GetMapping("sub5") 이렇게 줄일수가 있다.

    //@RequestMapping(value = "sub5",method = RequestMethod.POST)
    @PostMapping("sub6")
    해석 : 여기도 똑같이 줄일 수가 있다.
    public void method6(
            String username,
            String password
    ){
        System.out.println("username = " + username);
        System.out.println("password = " + password);
    }


    HttpSession : 세션은 일정 시간동안 같은 클라이언트(브라우저)에서 들어오는 일련의 요구를 하나의 상태로 보고, 
    그 상태를 유지하는 기술을 말합니다. 사용자가 웹서버에 접속한 후 브라우저를 종료할 때 까지 세션이 유지됩니다.

    Session : 나 혼자만 저장하는것
    application: 모든 사람이 접속과 저장을 할 수 있는 것과

    setAttribute : 속성을 저장하다 
    getAttribute : 속성을 꺼내다 , 불러오다

    쿠키 : local pc,저장,삭제기한 설정
    session : 삭제기한 없고,브라우저 종료시 다 삭제


    redirection : 다른 곳(location)으로 가!!! 라는 응답(response, 302)

         
    @GetMapping("sub12")
    public String method12(String address, RedirectAttributes rttr) {
        String processed = address + " 처리 결과";
        rttr.addFlashAttribute("processedValue", processed);
        return "redirect:/main16/sub13";
    }
    @GetMapping("sub13")
    public void method13(Model model) {
        Object processed = model.getAttribute("processedValue");
        System.out.println("processed = " + processed);
    }
    설명 : RedirectAttributes : 이 파라미터는 보내고 버려지는 속성을 가지고 있다
    RedirectAttributes 안에 들어있는 메소드는 addFlashAttribute속성이 있어서
    return "redirect:/main16/sub13";   sub13으로 보내고 없어진다


structured
query
language
database
relational database

생성 : Create
읽기 : Read
수정 : Update
삭제 : Delete

-----------------------------------------------------------------------
sql

-- ORDER BY 로 지정해주면 순서대로 지정을 해줄 수가 있다 
-- DESC = 밑에서부터 즉 내림차순 ASC = 오름차순부터 (생략가능하다)
-- AS : 컬럼명(테이블명) 변경
-- 문자열 연결은 concat 사용

SELECT EmployeeID, CONCAT(LastName, FirstName)  FROM employees;
SELECT EmployeeID, CONCAT(LastName,' ', FirstName) AS name  FROM employees;
두번째 ' '를 주므로써 띄어쓰기를 하였고 AS로 이름을 name 으로 바꿨다.

여러개의 테이블을 모아둔 것을 SCHEMA
모르는 단어 : 
modulo,remainder ,djxmfbajsxm




Like 커리



SELECT *
FROM customers
WHERE CustomerName = 'Around the Horn';
SELECT *
FROM customers
WHERE CustomerName LIKE '%the%';
SELECT *
FROM customers
WHERE CustomerName LIKE '%ch%';

-- LIKE : 검색
-- %, _ 기호(wildcard)와 같이
SELECT *
FROM customers
WHERE CustomerName LIKE 'ch%'; -- % : ch로 시작하는 직원네임
SELECT * FROM customers
WHERE CustomerName LIKE '%er'; -- % es로 끝나는 직원네임
SELECT * FROM customers
WHERE CustomerName LIKE '%er%'; -- % 중간에 er이 들어간 직원네임

SELECT * FROM employees
WHERE FirstName LIKE '______';-- _ : 1개의 문자 아무거나
SELECT *
FROM employees
WHERE LastName LIKE '____'; -- _ :1rodml 문자 아무거나

SELECT *
FROM employees
WHERE LastName LIKE '_e%';

-- 예) ch로 시작하는 상품명 조회
SELECT * FROM products
WHERE ProductName LIKE 'ch%';
-- 예) es로 끝나는 상품명 조회
SELECT * FROM  products
WHERE ProductName LIKE '%es';
-- 예) 중간에 use가 들어간 상품명 조회
SELECT * FROM products
WHERE ProductName LIKE '%use%';
-- 예)  두번째 글자가 u인 상품명 조회
SELECT * FROM products
WHERE ProductName LIKE '_u%';

---------------------------------------------------------------
INSERT INTO 테이블 컬럼에 값을 넣는 SQL구문입니다.값은 테이블 전체 컬럼에 넣을 수도 있고,
일부 컬럼에만 넣을 수도 있다.
INSERT INTO employees (EmployeeID, FirstName, LastName)
    VALUE (15, '김', '두식');

INSERT INTO employees (EmployeeID, FirstName, LastName)
    VALUE (16, '김');

SELECT * FROM employees ORDER BY EmployeeID DESC;

-- 값의 타입에 따라 넣는 방법이 다름
INSERT INTO employees (EmployeeID)
    value (15);
INSERT into employees(EmployeeID)
value ('16'); -- 되긴 됨 --
INSERT INTO employees (LastName)
VALUE ('son');
INSERT INTO employees(LastName)
value ('10000'); -- 따음표 사용 권장
INSERT INTO employees(LastName)
value (10000);
INSERT INTO employees (BirthDate)
value ('2000-01-01');
SELECT * FROM employees order by EmployeeID DESC;
INSERT INTO products(price)
VALUE (20.10);
INSERT INTO products(price)
VALUE ('30.33'); -- 되긴 됨..


 




 -- DELETE FROM tableName WHETE 조건
-- !! WHERE 절 꼭 작성!!--

SELECT *
FROM employees
WHERE LastName = '손';
DELETE FROM employees WHERE LastName = '손';

-- 지우기 전 같은 where 절로 지울 레코드인지 확인!!!

SELECT *
FROM employees
WHERE FirstName = '김';
DELETE FROM employees WHERE FirstName = '김';

SELECT * FROM employees ORDER BY EmployeeID DESC;

-- 예) 직원 테이블에 오늘 입력한 레코드들 지우기
 SELECT * FROM employees
          WHERE LastName = '이';
DELETE FROM employees WHERE LastName = '이';
-- 예) 상품테이블에 오늘 입력한 레코드들 지우기
SELECT * FROM products;
DELETE FROM products WHERE ProductName ='돈까스';


executeUpdate 란?
executeUpdate 메서드는 데이터베이스에서 데이터를 추가(Insert), 삭제(Delete), 수정(Update)하는 SQL 문을 실행합니다. 
메서드의 반환 값은 해당 SQL 문 실행에 영향을 받는 행 수를 반환합니다.

ExecuteQuery 란?
수행결과로 ResultSet 객체의 값을 반환합니다.




get은 주소값을 입력했을 때 실행이 되고
post는 눌렀을때 보내지는 것
public void method2(@RequestParam(value = "pid", required = false) Integer royy)
required = false : required를 쓰면 false 실행이 안되도 fales 지정해주는것



  @GetMapping("sub2")
    public void method2() {} ----> PostMapping을 했기 때문에 GetMapping을 써야 했다. jsp로 갈려면
 @PostMapping("sub1")
    public void method1(@RequestParam(value = "id"--->jsp에서 파라미터로 받아온것, required = false) Integer customerId---> Integer로 변수 지정하여서 밑에서 쓸수 있다) throws SQLException {

        if (customerId == null) {
            System.out.println("삭제를 id를 넣어주세요");
            return; -----> PostMapping으로 보냈으니까 return값이 필요
        }
        String sql = """
                DELETE FROM customers
                WHERE customerId = ?
                """;
        Connection connection = dataSource.getConnection(); --->데이터베이스를 가져오는 
        PreparedStatement statement = connection.prepareStatement(sql); -----> ?물음표를 쓸려면 필요한 것
        try (connection; statement;) {

            statement.setInt(1, customerId);
            int rows = statement.executeUpdate();// inset, delete, update (Integer)

            if (rows == 1) {
                System.out.println(rows + "개 레코드 잘 지워짐");
            } else {
                System.out.println("잘 지워지지않음");
            }
        }
    }



UPDATE

-- 예) 5번 직원이 notes 변경하기
SELECT * FROM employees WHERE employeeID;
UPDATE employees
SET Employees.Notes = '안녕'
where EmployeeId =5;
-- 예) 1번 공급자의 전화번호, 주소 변경하기
SELECT * FROM suppliers WHERE supplierid= 1;
UPDATE suppliers
SET suppliers.Phone = '1234'
WHERE supplierId = 1;

SELECT * FROM products
WHERE CategoryID =1;
UPDATE products
SET Price = Price * 2
WHERE CategoryID = 1;




PRIMARY KEY : not null, UNIQUE를 합쳐 놓은것
AUTO_INCREMENT : 숫자 1,2,3,4,5... 자동적으로 늘어나는 것




-- 예) 1996년 7월 4일 에 주문한 고객명 (customers, orders)
SELECT CustomerName,OrderDate
FROM customers c            --> 원래는 customers AS c 이렇게 써야하는데 AS가 생략됐다
                                customers가 기니까 c로 쓰기 편하게 지정을 해준거다
         JOIN orders o          --> 이것도 마찬가지 위에랑 같은 것
                                JOIN 은 customers와 orders랑 같이 쪼인 하는 것
              ON c.CustomerID = o.CustomerID  --> ON은 a = b 와 비슷하다 
                                            즉 둘이 값이 똑같애 해주는 것이다
WHERE o.OrderDate = '1996-07-04';        --> WHERE로 보고싶은 걸 적으면 된다



-- 예) 1996년 7월 4일 에 주문을 담당한 직원명 (employees, orders)
SELECT e.LastName, e.FirstName
FROM employees e
         JOIN orders o
              ON e.EmployeeID = o.EmployeeID
WHERE o.OrderDate = '1996-07-08';

-------------------------------------------------------------------------

-- 예 )  1996년 7월 9일에 주문한 상품명 (orders, orderDetails, products)
SELECT OrderDate, ProductName
FROM orders o
         JOIN orderdetails od
              ON o.OrderID = od.OrderID
         JOIN products p                -->위에 예제랑 똑같지만 여기선 한번 더 JOIN을 하였다
                                        즉 비유하자면 a = b = c 셋다 같다는 점이다
              ON od.ProductID = p.ProductID
WHERE OrderDate = '1996-07-09';


-- 예 ) 'Chang' 상품이 주문된 날짜들
SELECT ProductName, OrderDate, c.CustomerID, p.ProductID,
CONCAT(e.FirstName,' ',         --> CONCAT(e.FirstName,' ',e.LastName) fullName 이렇게 코드를 작성하면
                                fullName이 찍힐 때 firstName과 lastName 합쳐져서 나온다 
                                그리고 중간에 ,' ', 이것은 띄어쓰기를 하기 위함이다.
    e.LastName) fullName
FROM products p
         JOIN orderdetails od
              ON p.ProductID = od.ProductID
         Join orders o ON od.OrderID = o.OrderID
         JOIN customers c
              ON o.CustomerID = c.CustomerID
         JOIN employees e
              ON o.EmployeeID = e.EmployeeID
WHERE ProductName = 'Chang';




   -- 예) 1번 카테고리에 있는 상품이 주문된 주문번호 (orderDetails, products)
SELECT ProductID FROM products WHERE CategoryID = 1;

SELECT OrderID FROM orderdetails
WHERE ProductID IN (SELECT ProductID FROM products WHERE CategoryID = 1);
-- 예) 1번 카테고리에 있는 상품이 주문된 날짜 (orderDetails, products)
SELECT OrderDate FROM orders
WHERE OrderID IN (SELECT OrderID FROM orderdetails
                  WHERE ProductID IN (SELECT ProductID FROM products WHERE CategoryID = 1)); ----> 쉽게 정직하게 할려면 이렇게도 쓰지만 밑에 예제가 더 간결하고 코드도 적다
                                                                                                    
SELECT *
FROM orders o JOIN orderdetails od ON o.OrderID = od.OrderID                                   --> 즉 join인을 사용하면 좋다.
              JOIN products p ON od.ProductID = p.ProductID
WHERE p.CategoryID = 1;  



 --> join 으로 코드를 작성하였다
 employees랑 orders 에서 주문한적 없는 직원이름을 알아내시오
SELECT e.LastName,e.FirstName         
FROM employees e LEFT JOIN orders o         -->LEFT JOIN 은 
ON e.EmployeeID = o.EmployeeID
WHERE o.EmployeeID IS NULL;


   .then(param => param.data) 밑에 있는 코드를 줄이면 이렇게 된다.    
                .then(function (param) {
                    return param.data;
                })

     .then(function (response) {
     return response.data;
     위에 있는 코드를 밑에 코드로 줄일수 있다 자바로 해석하면 람다식
       .then(response=>response.data)
   
    .then(function (data) {
    console.log(data.list[1]);
    위에 있는 코드를 밑에 코드로 줄일수 있다 자바로 해석하면 람다식
     .then(data=>console.log(data.list[1]))
   


     
        let  b = {             --> let
            city: "seoul",
            country: "korea"
        };
        console.log(b.city);
        console.log(b.country);

        let {city,country} = b;    -->b.city를 쓰고 싶지 않으면 {} 를 줘서 그냥 city를 쓰면 된다.
        console.log(city);
        console.log(country);
        


         <button onclick="ajax11()">button11</button>
    <script>
        function ajax11() {
            axios.get("/main38/sub4")
                .then(response => response.data)
                .then(({price,birth,list,city}) => console.log(data.price));//3000 --> 그래서 {여기 안에 적어놓으면 b.price안해도 price 바로 쓸수 있다 }
        }
    </script>




     let f = {
            name3: "kim",
            city3: "busan"
        };
        let{name3,city3= "인천",address3 = "신촌"} = f; // 없을 때 기본값 할당 값이 없을 때 = "" 을 통해서 값을 지정해 줄수 있다
        console.log(name3);
        console.log(city3);
        console.log(address3);


         let[h,i,j] = g; // destructuring assignment
        console.log(h);
        console.log(i);
        console.log(j);

        let [k,l] = g;
        console.log(k);
        console.log(l);

        let [m,...n] = g;   --> ...n 은 나머지
        console.log(m) //30
        console.log(n); //[40,50]

        let[...o] = g;  --> ...o도 나머지
        console.log(o); // [30,40,50]

        .then() : 성공햇을 때 실행되는 메소드
        .catch() : 실패했을 때 실행되는 메소드
        .finally() : 항상 실행되는 메소드

        ResponseEntity : 응답코드, 응답본문 작성 가능한 객체

        ResponseEntity.notfound().build();  -->404

        working  ---> staging ---> .git directory
        Directory---> Area    ---> (Repository)
            <---------checkout the project
            stage Fixes
            ----------->
                add             commit
                        ----------------->
                                commit


        git----------------------------------------


        git 명령어
        pwd : 현재 디렉토리 출력
        ls : 현재폴더의 파일목록
        ls -l :자세히 보기
        ls -A : 숨긴파일도 보기
        ls -a : 숨긴파일도 보기     ./ ../ 첫줄에 이게 나온다./현재폴더 ../ 이전폴더
        ls -Al : 숨긴파일도 보고 자세히도 보고
        ctrl + l : 화면정리
        ctrl + c :실행취소
        cd : 폴더변경
        cd .. : 상위폴더
        cd - : 직전폴더로 이동
        mkdir : 폴더 만들기
        touch : 새파일만들기 마지막변경시간 변경
        echo : 콘솔에 출력
        > : 왼쪽의 출력을 오른쪽에 인풋으로
        >> :  왼쪽의 출력을 오른쪽에 인풋으로 기존내용 보존 (append)이어붙이기
        cat (more,less) : 파일내용 보기
        git init : 현재폴더를 git이 관리하는 폴더로 만들기
        git status : 현재 리포의 상태보기
        git add : 변경사항을 stage에 올리기
        git add . : 모든 파일 stage로 올리기
        git commit : 변경사항 생성
        git commit -am : tracked 파일 add, commit을 함께
        git log : 변경사항 히스토리 보기
        git log --oneline : 변경사항을 한줄로 보기
        git log --all : 모든 커밋 보기
        git log --oneline --all : 모든 커밋을 한줄로 보기
        git checkout : 변경사항 옮기기
        git switch : 브랜치 옮기기
        git switch -c 브랜치명: HEAD 있는 곳으로 가서 브랜치 만들고 기존 브랜치는 오른쪽으로 이동
        git switch 브랜치명 : HEAD가 브랜치명으로 이동g
        git restore --staged : unstage 하기
        git commit -am "tracked 파일 add,commit함께 올리는 것
        git log --graph : 그림으로 표현 (누가 부모인지 이어졌는지)
        git merge 브랜치명 : 브랜치명의 변경사항을 현재 브랜치에 반영 
                            HEAD와 브랜치명이 지정된 브랜치명으로 옮겨진다 지정된 브랜치명은 오른쪽으로 이동한다
        git branch 아무거나 : 브랜치명 커밋번호 커밋번호에 '브랜치명'라는 별칭 생성        git branch -d 브랜치명 : 브랜치명 지우기
        git remote -v : 자세히 보기
        git branch -vv : 브랜치 더 자세히보기
        git remote -c 브랜지명 : 브랜치를 만들고 이동
        git remote : 원격리포지토리보기
        git push -u : 원격브랜치 추적하기  --> 예) origin master
        git push : 원격리포에 올리기
        git pull : push명령어는 현재 프로젝트의 커밋된(HEAD) 내용을 원격 저장소로 내보내는 명령어
                   pull 명령어는 원격저장소에서 fetch명령어로 가져온 후 merge까지 한번에 해 
                   실제 파일의 내용이 변경되는 명령어입니다
        git fetch : 원격리포의 내용 로컬에 내용만 로컬에 있어서 HEAD 보다 위에 있어서 
                    fetch를 쓰고 merge까지 적어줘야 두가지 다 있을 수 있따
        git fetch -p                        -->
        git fetch --prune : 삭제원격브랜치   --> 위에랑 같은 뜻
        #pull request merge 해달라는 요청    
        3way merge
        HEAD : 현재 커밋 위치
        branch : 커밋의 별칭

        git remote add origin
        git remote
        git remote -v
        git push -u origin master
        git branch
        git branch -vv
        HEAD : 현재위치
        HEAD~
        HEAD~1
        HEAD~~
        HEAD~2
        HEAD~3

        세이브(게임 임시저장 죽으면 저장되있던 곳에서 다시 시작) = 커밋
        

        @Select("""
        SELECT CustomerName
        FROM customers
        WHERE CustomerID = #{asdfas}   ----> #{}이건 ? 와 비슷한 것이다 
        """)
        // 파라미터가 하나면 이름이 일치하지 않아도 됨
        // 두 개 이상이면 꼭 이름을 맞춰 줘야함! (asdfas 와 customerID)

        String selet1(int customerID);

        @Select("""
        SELECT CustomerName
        FROM customers
        WHERE CustomerID = #{})



        DAO

        Data Access Object의 약자로, 데이터베이스의 데이터에 접근하기 위해 생성하는 객체이다.
        데이터베이스에 접근하기 위한 로직과 비즈니스 로직을 분리하기 위해 사용한다.
        간단하게, DB에 접속하여 데이터의 CRUD(생성, 읽기, 갱신, 삭제) 작업을 시행하는 클래스이다.
        JSP 및 Servlet 페이지 내에 로직을 기술하여 사용할 수 있지만, 코드의 간결화 및 모듈화, 유지보수 등의 목적을 위해 별도의 DAO 클래스를 생성하여 사용하는 것이 좋다.
        한 줄 요약 : DAO는 DB를 사용하여 데이터의 조회 및 조작하는 기능을 전담하는 오브젝트이다.


        DTO

        Data Transfer Object의 약자로, 계층간 데이터 교환을 위한 자바빈즈를 뜻한다.
        또한 DTO는 VO(Value Object)와 용어를 혼용해서 많이 사용하는데, VO는 읽기만 
        가능한 read only 속성을 가져 DTO와의 차이점이 존재한다.
        일반적으로 DTO는 로직을 가지고 있지 않은 순수한 데이터의 객체이며 객체의 속성과 그 속성의 접근을 
        위한 getter 및 setter 메소드만을 가지고 있다.
        즉 변환 해주는 


        chakra

            base: "0em", // 0px
            sm: "30em", // ~480px. em is a relative unit and is dependant on the font size.
            md: "48em", // ~768px
            lg: "62em", // ~992px
            xl: "80em", // ~1280px
            "2xl": "96em", // ~1536px

            rsf : 초기화에서 시작 할때 세팅



        function App(props) {
                function func1() {
                console.log("func1 실행");

                return (

                <div>
                    <MyComp executeClick={func1}>Button1</MyComp>
                </div>
                         );

        설명 : func1 함수를 사용할때는 function을 만들고 지정해서 써야한다
                하지만 더 쉽게 애로우function을 활용하면 더욱 간편하다

                return 
                 <Button onClick={() => console.log("first")}>버튼1</Button>
        설명 : 저 긴 위 코드가 애로우function을 써서  이렇게 간편하게 줄어들었다
            

            function handleClick() {
                console.log("second");
            }
            return
            <div>
            <Button onClick={handleClick}>버튼2</Button>
            <div>

        맨위에 처럼 함수를 지정하고 사용할때는 관습처럼 함수 이름 앞에 handle 붙여준다고 한다.


        모든 이벤트 인터페이스 이름은 "Event"로 끝난다는 사실도 확인할 수 있습니다.

        DOM
        도큐먼트 오브젝트 모델


        메소드-----------------
        e.preventDefault(); -->e. 뜻은 event 를 줄여서 e 
        이 메소드의 뜻은 방지 ,예방 이라는 뜻을 가지고있다
        실행하려는 것을 정지시키고 멈추거나 다른 것을 실행 할 수 있다

        //event bubbling 막는 메소드
        e.stopPropagation();

        useState : useState는 컴포넌트에 상태 변수를 추가할 수 있는 React Hook입니다.
        onChange :  이벤트 핸들러 함수. 제어된 입력에 필요합니다. 
                    사용자가 입력 값을 변경하면 즉시 실행됩니다(예: 키 입력 시마다 실행). 
                    브라우저 입력 이벤트처럼 작동합니다.

        let a = 10
        let b = 20
        a+b = 30

        let a = 10
        let b = "20"
        a+b = '1020'

        a+Number(b) = 30;  -->number를 대문자 Number를 적어주면 string이였던 글자가 숫자로 변한다


        function App(props) {
  const [text, setText] = useState("hello");

  function handleButtonClick() {
    //text 라는 state 값 변경
    setText("greeting");
  }

  return (
    <div>
      <p>
        <Button onClick={handleButtonClick}> 상태변경</Button>
        {text}
      </p>
    </div>
  );
}

        설명 : 버튼을 누르면 handleButtonClick 메소드가 실행 useState에서 setText를 지정해줬으니까
        setText("greeting")을 넣어주면 버튼을 누를때 greeting로 변경이 된다.

        use = hook
         // HOOK : use 로 시작 하는 함수
        // hook은 컴포넌트 상단에 작성해야함

        자바에서는 string 은 참조타입이지만
        자바스크립트에서는 string 가본타입

        구조할당

        deepcopy 값
        얕은 카피 주소




                    function App() {
              const [message, setMessage] = useState("");
              const [obj, setObj] = useState({ message: "" });
            
              function handleObjectMessageChange(e) {
                // obj.message = e.target.value;
                // setObj(obj);
            
                // const newobj = { ...obj };
                // newobj.message = newobj.message + 1;         ---> 이 코드를 밑에 있는 코드로 줄일 수 있다
                // setObj(newobj);
            
                setObj({ obj, message: e.target.value });
              }
            
              return (
                <>
                  <Box>
                    <Input value={message} onChange={(e) => setMessage(e.target.value)} />
                    <Text>{message}</Text>
                  </Box>
                  <Box>
                    <Input value={obj.message} onChange={handleObjectMessageChange} />
                    <Text>{obj.message}</Text>
                  </Box>
                </>
              );
            }



        // setItems([...items, text]); 밑에 코드를 줄여서 위에 코드처럼 쓸 수 있다 (복사)

    const nextItems=[...items];
    nextitems.push(text);
    setItems(nextItems);

        
        // setItems(items.filter((item, i) => i != index)); --> 이 코드를 해석하면 밑에 있는 코드와 같다 (지우기)

      const nextItems = [...items];
      nextItems.splice(index, 1);

      setItems(nextItems);

      shift와 F6을 같이 누르면 같은 값 이름이 같이 지정 되면서 이름을 바꿀수 있고 어떤게 같은 것인지 알수 있다

      draft : 복사된 값 선배들이 이렇게 지정했다 그리고 함수명은 관례대로 update를 앞에 써서
                updateperson1 이렇게 지정을 한다 그리고 원래 객체인 것 처럼 사용할 수 있다 

      onChange : 입력하면 값이 바뀌고 등록되는 
      
        MyComp1에 있는 버튼을 눌렀을때  MyComp2의 텍스트가 변경되는 
       const [message, setMessage] = useState("hello"); 이것을 App메소드 밖에 쓰는 것이 아니라
       MyComp1 MyComp2가 같이 일을 해야 하니 메인인 App메소드안에 적어야 한다
       usestate를 App에 적으면 된다
       App에서 받을 려면 트랍(파라미터,MyComp1 onClick= onClick이 트랍)으로 받아야 한다 -->예)  <MyComp2 message={message}></MyComp2> 요런 식으로
        message는 MyComp2에 setmessage는 MyComp1에





        -----> 예시 

        function MyInput({ address, onChange }) {
  function handleInputChange(e) { 
    onChange(e.target.value);           ------> arrow funtion으로 바꾸면 (e) => onChange(e.target.value)} 이렇게 된다
    --> 2. e로 onChange를 받고 target.value값을 받는다
  }
  return (
    <Box>
      <Input value={address} onChange={handleInputChange}></Input>
        --> 1. Input으로 입력받은 값을 handleInputChange function으로 이동
    </Box>
  );
}

function MyText({ address }) {
  return (
    <Box>
      <Text>{address}</Text>
    </Box>
  );
}

function App(props) {
  const [address, setAddress] = useState(""); -->5번

  function handleInputChange(text) {        -->4번
    setAddress(text);
  }
  return (
    <div>
      <MyInput address={address} onChange={handleInputChange}></MyInput>  -->6번
      --> 3번 
      {/*//클릭*/}
      <MyText address={address}></MyText>
      {/*바뀌게*/}
    </div>
  );
}




--->예시 createContext()

function CComp() {
  // 3. context 사용하기 : useContext(Context); 
  const message = useContext(MessageContext);   -->createContext()를 useContext()로 받을 수가 있다

  return <Text>받은 메시지 : {message}</Text>;
}

function Bcomp() {
  return <CComp />;
}

function Acomp() {
  return <Bcomp />;
}

function App(props) {
  const [message, setMessage] = useState("");

  // message state를 Ccomp에 전달 하기
  // 1. context 만들기 : createContext();
  // 2. context에 state 넣기
  //    : <Context.Provider value={state}></Context.Provider>
  // 3. tree안에 context사용하기

  return (
    <div>
      <Button onClick={() => setMessage("바꾼 메시지!!!")}>
        메시지 바꾸기
      </Button>
      <MessageContext.Provider value={message}>     -->2. state 값을 받으려면 MessageContext.Provider value={} 여기에 입력해야된다
        <Acomp />
      </MessageContext.Provider>
    </div>
  );
}

// 1. context 만들기
// context 이름은 대문자로 시작하고 Context로 끝남 // App 밖에다 써야한다
const MessageContext = createContext(null);  ----> 1. CComp에서 쓸려면 createContext()함수를 쓰면 된다

export default App;

useEffect(()=>{},[]) :첫번째 파라미터는 실행할 함수
                     :두번째 파라미터는 첫번째파라미터를 실행 시키는 값, 빈 배열이면 초기 렌더링 때만 실행됨
요청 받을 때 쓰는 then() 메소드


useEffect : 
첫번째 파라미터 :(setup) The function with your Effect`s logic. 부작용이 있는 함수.
두번째 파라미터 : setup을 실행시키는 값의 나열(배열)
//              빈 배열이면 처 렝더링 때만 실행됨

@RestController = @Contrller 와 @R


react router   :Link 로 하면 페이지만 바뀌는 것이 아닌 글만 바뀐다

유리수는 정수와 분수이고 그 외에 것들은 무리수다
부등식은 두 수 또는 식에 대한 크기를 비교하는 식이다
비례식은 a,b의 비가 같은 경우, 두비를 등호(=)를 이용하여 나타탠 수식을 말한다

useToast() : 밑에 토스트 처럼 띄어지게 하는 것
useNavigate() : 주소를 바꿔주는 페이지가 완전히 바뀌지 않고 화면만 바뀌는 훅
useParams() : 다이나믹 파라미터를 받아주고 객체로 변환해준다
ResponseEntity : ResponseEntity 클래스를 사용하면, 
                 결과값! 상태코드! 헤더값!을 모두 프론트에 넘겨줄 수 있고, 
                 에러코드 또한 섬세하게 설정해서 보내줄 수 있다는 장점이 있다!
                 상태코드를 강제로 하고 싶어서 사용한다.
useDisclosure() : model을 쓸 수 있게 함수를 불러 오는것
new URLSearchParams() : 쿼리를 불러오고 거기에 쓸 수 있는  것

ok() build();

toast({
    description:
})

1 + 2 + 3 + 4 + 5 + 6 을 리턴하는 코드 :
1번 : Arrays.stream(String.valueOf(n).split("")).mapToInt(Integer::parseInt).sum();
2번 :  int answer = 0;
        int x = 0;
        for (int i = 0; i < 7; i++) {
            if (Math.pow(10, i) == n) {
                x = i + 1;
                break;
            } else if (Math.pow(10, i) > n) {
                x= i;
                break;
            }
        }
        for (int i = x; i >= 1; i--) {
            answer += n / (int) Math.pow(10, i - 1);
            n = n - (int) Math.pow(10, i - 1) * (n / (int) Math.pow(10, i - 1));
        }
        return answer;
    2번 설명 : Math.pow 메소드를 사용하여 진행하였다


1번 : int[] answer = Arrays.copyOfRange(numbers, num1, num2+1);

알파벳 모음을 제거한 배열을 리턴
1번 :  String[] alpha = new String[]{"a","e","i","o","u"};
        for (String a : alpha) {
            my_string = my_string.replaceAll(a, ""); --> my_string으로 받아야 값이 변하면서 원하는 결과를 받을 수있다
                                                        answer = my_string.replaceAll(a, ""); 이러면 안됌
        }
        return my_string;


2번 :   StringBuilder sb = new StringBuilder();
        String[] love = {"a","e","i","o","u"};
        String[] can = my_string.split("");
        for(int i = 0; i< can.length; i++) {
            int count = 0;
            for(int j = 0; j < love.length; j++) {
                if(love[j].equals(can[i])) {  
                    count++;
                }     
            }
            if (count == 0) sb.append(can[i]);
            count = 0;
        }
        
        return sb.toString();
    



g
모르는 것들 
데이터베이스 BoardService 코드들
sql inserted DATETIME DEFAULT now()

루트 : 설명 1 : 2 2제곱은 4이다 루트로 표현하면 2는  루트4 이다
       설명 2 : 3의 3제곱은 9이다  루트로 표현하면 3은 루트9이다
       즉 : 2의2제곱 = 4 ->(루트로표현) 2 = 4루트
            3의3제곱 = 9 ->(루트로표현) 3 = 9루트 